[{"content":"Con la aplicación gitleaks puedes detectar si un repositorio, o directorio expone claves secretas.\nPuedes hacerlo de modo manual\n1 2 gitleaks -git /path/to/repo gitleaks -dir /path/to/dir O puedes añadir este archivo .pre-commit-config.yaml a la raiz de tu repositorio github, lo que lanzará este commando antes de realizar git push lo que evitará que envies credenciales.\n1 2 3 4 5 6 # .pre-commit-config.yaml repos: - repo: https://github.com/gitleaks/gitleaks rev: v8.24.0 hooks: - id: gitleaks ","date":"2026-01-20T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/detectar-claves-en-repositorio/","title":"Detectar Claves En Repositorio"},{"content":"Gracias a esta app puedes vigilar el output de una tarea repetitiva.\n1 2 3 watch ls -alh . # mostrará el contenido de la carpeta actual,, actualizando cada dos segundos watch --differences df -h # mostrará el uso de los discos casi en tiempo real watch --chgexit lsbl # Saldrá del comando al detectar un cambio ","date":"2026-01-20T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/watch/","title":"Watch"},{"content":"Requisitos Exporta estas variables, modifica las rutas a tu gusto\n1 2 3 4 export ANDROID_HOME=$HOME/Android/Sdk export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin export PATH=$PATH:$ANDROID_HOME/platform-tools export PATH=$PATH:$ANDROID_HOME/emulator Clona el repositorio\n1 2 git clone --recursive https://github.com/koel/player.git cd player Instala apps necesarias, con Arch sería algo asi\n1 2 sudo pacman -S android-tools jdk-openjdk sudo paru -S flutter Ejecuta android-tools e instala:\nal menos un sdk Android SDK Command-line Tools NDK (Side by side) Acepta las licencias de android con flutter doctor --android-licenses\nVerifica la instalación con flutter doctor -v si no tienes instalado chrome es probable que aparezca marcado en rojo, pero no lo necesitas\nInstala requisitos de flutter con flutter pub get\nInstalación Ejecuta este commando, tardará un rato\nflutter build apk --debug\nEs possible que te encuentres con errores de versiones, en mi caso NDK, sorteé el mismo modificando el archivo\nnano PATH/player/android/app/build.gradle\nespecificando la versión instalada de NDK\n1 2 android { ndkVersion \u0026#34;29.0.14206865\u0026#34; // Cambia esto para usar tu versión Puedes ver que versiones tienes instaladas con\n1 2 3 4 ls -la /home/huan/Android/Sdk/ndk/ # en mi caso buscaba este archivo ls -la /home/huan/Android/Sdk/ndk/28.2.13676358/source.properties Al finalizar te muestra la ruta donde se ha creado la apk\n","date":"2026-01-19T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/construir-koel-app-para-android/","title":"Construir Koel App Para Android"},{"content":"Para saber los permisos de archivo o directorio stat --format '%a' \u0026lt;file\u0026gt;\n","date":"2026-01-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/c%C3%B3digo-chmod/","title":"Código Chmod"},{"content":"","date":"2026-01-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/conocer-numero-chmod/","title":"Conocer Numero Chmod"},{"content":"Con este commando puedes copiar un archivo a tu host\n1 2 3 4 pct pull \u0026lt;vmid\u0026gt; \u0026lt;path\u0026gt; \u0026lt;destination\u0026gt; # por ejemplo pct pull 135 /root/contenedores/pollo.zip pollo.zip ","date":"2026-01-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/copiar-archivo-de-un-contenedor-de-proxmox/","title":"Copiar Archivo De Un Contenedor De Proxmox"},{"content":"Muestra la previsión metereológica para la ciudad que elijas durante los próximos días\n1 curl wttr.in/Jerez ","date":"2026-01-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/el-tiempo-en-el-terminal-oneline/","title":"El Tiempo En El Terminal Oneline"},{"content":"Para poder borrar todo el contenido de una carpeta excepto una ruta concreta se puede:\n1 find $carpeta -maxdepth 1 -type d ! -iname ${ruta} -delete no termina de funcionar asi\n","date":"2026-01-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/excluir-path-de-busqueda/","title":"Excluir Path De Busqueda"},{"content":" https://serverfault.com/questions/1082356/how-to-make-wake-on-lan-persistent-in-debian-buster\nPrimero modifica la BIOS para que permita WOL\nSegundo comprueba que tu tarjeta de red sea capaz de WOL;\nsudo ethtool eth0\n1 2 Supports Wake-on: pumbg Wake-on: d Actívalo:\nsudo ethtool -s eth0 wol g\nComprueba que funcione, y para hacerlo permanente has de crear un servicio de systemd:\nLuego crea este servicio para mantener persistencia:\n1 2 3 4 5 6 7 8 9 10 11 $ cat /etc/systemd/system/wol.service [Unit] Description=Configure Wake-up on LAN [Service] Type=oneshot ExecStart=/sbin/ethtool -s eth0 wol g [Install] WantedBy=basic.target Por ultimo actíva el servicio con system-ctl:\nsudo systemctl enable wol.service\nsudo systemctl daemon-reload\n","date":"2026-01-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/wakeonlan-pa-siempre/","title":"Wakeonlan Pa Siempre"},{"content":" Crea el archivo .env\nEste archivo contendrá tus variables de entorno: 1 2 3 # Archivo .env VAR1=\u0026#34;valor1\u0026#34; VAR2=\u0026#34;valor2\u0026#34; Escribe el script Bash que cargará .env\nPuedes usar source para cargar las variables del archivo en el entorno del script: 1 2 3 4 5 # Cargar variables desde .env source \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/.env\u0026#34; # Usar las variables echo \u0026#34;VAR1 es: $VAR1\u0026#34; echo \u0026#34;VAR2 es: $VAR2\u0026#34; Python Puedes usar el paquete python-dotenv con pip install python-dotenv.r\n1 2 3 4 5 6 import os from dotenv import load_dotenv load_dotenv() API_KEY = os.gentenv (\u0026#39;API_KEY\u0026#39;) ","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/cargar-archivos-.env-en-scripts/","title":"Cargar Archivos .Env En Scripts"},{"content":" askubuntu\nEl proceso se puede resumir de la siguiente manera:\nInstalar iw, una herramienta para configurar dispositivos inalámbricos Linux:\n1 sudo apt install iw Enumerar los dispositivos inalámbricos disponibles:\n1 iw list Mostrar el estado de activación inalámbrica del dispositivo phy0 (ajustar el dispositivo según el resultado del commando anterior):\n1 iw phy0 wowlan show La sección de compatibilidad con WoWLAN muestra los modos de WoWLAN compatibles.\nHabilitar WoWLAN para el dispositivo phy0 con magic-packet:\n1 sudo iw phy0 wowlan enable magic-packet Nota: Para que WoWLAN funcione, la opción de activación de LAN en la BIOS debe estar habilitada.\n","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/configurar-wakeonlan-via-wifi/","title":"Configurar Wakeonlan Via Wifi"},{"content":"source\nSi tienes demasiadas llaves en el agente ssh, se prueban todas con el servidor, y se puede alcanzar el limit antes de acertar la correcta, pudiendo evitarlo asi:\n1 ssh -o IdentityAgent=none -i private_key_file_for_raspberry ... O puedes modificar la configuracion de ssh para ese host editando ~/.ssh/config\n1 2 3 4 5 HOST raspi42 hostname raspberry.myhome user pi IdentityAgent none IdentityFile private_key_file_for_raspberry ","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/demasiados-intentos-de-conexi%C3%B3n-ssh/","title":"Demasiados Intentos De Conexión Ssh"},{"content":"Usar variables en grep 1 grep -io Búsqueda En una carpeta (no recursiva) 1 grep \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/* Esto buscará \u0026quot;tu_string\u0026quot; en todos los archivos dentro de la carpeta, pero no en subcarpetas.\nBúsqueda Recursiva en subdirectorios 1 grep -r \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/ El flag -r (o -R) have que grep busque recursivamente en todos los subdirectorios.\nMostrar Número de línea en los resultados 1 grep -rn \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/ -n: Muestra el número de línea donde aparece el string. Ignorar Mayúsculas y minúsculas 1 grep -ri \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/ -i: Ignore diferencias entre mayúsculas y minúsculas. Buscar Archivos específicos (por extensión) Si solo quieres buscar en archivos .txt, usa:\n1 grep -r \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/ --include=\u0026#34;*.txt\u0026#34; Excluir Archivos o carpetas Si quieres excluir ciertos archivos o carpetas:\n1 grep -r \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/ --exclude-dir=\u0026#34;logs\u0026#34; Esto excluirá la carpeta logs de la búsqueda.\nMostrar Solo los nombres de los archivos que contienen el string 1 grep -rl \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/ El flag -l have que solo se muestren los nombres de los archivos que contienen la cadena, sin mostrar las líneas.\nUsar rg (ripgrep) Para mayor velocidad Si tienes ripgrep (rg) instalado, es mucho más rápido:\n1 rg \u0026#34;tu_string\u0026#34; /ruta/a/la/carpeta/ rg es recursivo por defecto y más eficiente que grep.\n","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/grep/","title":"Grep"},{"content":"Puedes usar !:# para referenciar segmentos del commando anterior\n1 2 3 4 5 6 7 touch archivo.txt echo !:1 archivo.txt touch 1.txt 2.txt echo !:2 2.txt ","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/hacer-referencia-a-argumentos-especificos-del-comando-anterior/","title":"Hacer Referencia A Argumentos Especificos Del Comando Anterior"},{"content":"Con megatools puedes registrar y subir archivos a mega.nz\n1 2 3 # Registra la cuenta megatools reg --register --username mail@domain.com --password QWERTY --name NAME # Continua con el comando propuesto por megatools para validar el registro 1 2 3 4 5 6 7 8 # Sube un archivo megatools put --path /Root/remote/path file.zip file2.csv --username mail@domain.com # Crea una carpeta megatools mkdir /Root/Path --username mail@domain.com # Sube un directorio megatools copy --source /path/to/dir --remote /Root/path --username mail@domain.com ","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/megatools/","title":"Megatools"},{"content":"Instalar 1 2 sudo apt install fuse sudo apt install ntfs-3g Montar 1 sudo mount -t ntfs /dev/sdXy /path ","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/montar-ntfs/","title":"Montar Ntfs"},{"content":"Exclude a Specific Directory 1 rsync -a --exclude \u0026#39;dir1\u0026#39; src_directory/ dst_directory/ ","date":"2026-01-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/rsync-evitar-directorio/","title":"Rsync Evitar Directorio"},{"content":"Veamos qué operaciones básicas puedes llevar a cabo utilizando Tar. Antes de comenzar, necesitarás SSH en tu servidor VPS. ¡Aquí hay una guía para ayudarte!\nCrear un archivo .tar en Linux Puedes crear compresiones .tar tanto para un archivo como para directorios. Un ejemplo de este tipo de archivo es:\n1 tar -cvf sampleArchive.tar /home/sampleArchive Aquí **/home/**sampleArchive es el directorio que necesita set comprimido creando sampleArchive.tar.\nEste commando usa las opciones **–**cvf que significan:\nc – crear un nuevo archivo .tar v – muestra una descripción detallada del progreso de la compresión f – nombre del archivo Crear un archivo .tar.gz en Linux Si deseas una mejor compresión, también puedes usar .tar.gz. Un ejemplo de esto es:\n1 tar -cvzf sampleArchive.tar.gz /home/sampleArchive La opción adicional z representa la compresión gzip. Alternativamente, puedes crear un archivo .tgz que sea similar a tar.gz. Te mostramos un ejemplo de esto último a continuación:\n1 tar -cvzf sampleArchive.tgz /home/sampleArchive Crear un archivo .tar.bz2 en Linux El archivo .bz2 proporciona más compresión en comparación con gzip. Sin embargo, esta alternativa tomará mas tiempo para comprimir y descomprimir. Para usarla, debes usar la opción -j. Un ejemplo de cómo se vería la operación es el siguiente:\n1 tar -cvjf sampleArchive.tar.bz2 /home/sampleArchive Dicha operación es similar a .tar.tbz o .tar.tb2. Te mostramos un ejemplo a continuación:\n1 2 3 tar -cvjf sampleArchive.tar.tbz /home/sampleArchive tar -cvjf sampleArchive.tar.tb2 /home/sampleArchive Cómo descomprimir archivos .tar en Linux El commando Tar de Linux también se puede utilizar para extraer un archivo. El siguiente commando extraerá los archivos en el directorio actual:\n1 tar -xvf sampleArchive.tar Si deseas extraer tus archivos a un directorio diferente, puedes usar la opción -C. Te mostramos un ejemplo de esto a continuación:\n1 tar -xvf sampleArchive.tar -C /home/ExtractedFiles/ Puedes usar un commando similar para descomprimir archivos .tar.gz, tal como se muestra a continuación:\n1 2 3 tar -xvf sampleArchive.tar.gz tar -xvf sampleArchive.tar.gz -C /home/ExtractedFiles/ Los archivos .tar.bz2 o .tar.tbz o .tar.tb2 pueden descomprimirse de manera similar. Para esto deberás teclear el siguiente commando en la línea de commando:\ntar -xvf sampleArchive.tar.bz2\nCómo listar el contenido de un archivo en Linux Una vez que hayas creado el archivo, puedes listar el contenido mediante un commando similar al siguiente:\n1 tar -tvf sampleArchive.tar Esto mostrará la lista completa de archivos junto con las marcas de tiempo y los permisos. Del mismo modo, para .tar.gz, puedes usar un commando como:\n1 tar -tvf sampleArchive.tar.gz Esto también funcionaría para archivos .tar.bz2 como se muestra a continuación:\n1 tar -tvf sampleArchive.tar.bz2 Cómo descomprimir un único archivo .tar Una vez que creas un archivo comprimido, puedes extraer un único archivo de ese comprimido. Esto lo puedes lograr con el commando que te mostramos a continuación:\n1 tar -xvf sampleArchive.tar example.sh Aquí example.sh es un archivo único que se extraerá del comprimido sampleArchive.tar. Alternativamente, también puedes usar el siguiente commando:\n1 tar --extract --file= sampleArchive.tar example.sh Para extraer un solo archivo de un comprimido .tar.gz puedes usar un commando similar al mostrado a continuación:\n1 tar -zxvf sampleArchive.tar.gz example.sh O alternativamente:\n1 tar --extract --file= sampleArchive.tar.gz example.sh Para extraer un solo archivo de un comprimido .tar.bz2 puedes usar un commando como este:\n1 tar -jxvf sampleArchive.tar.bz2 example.sh O, alternativamente, uno como este:\n1 tar --extract --file= sampleArchive.tar.bz2 example.sh Como puedes ver, el commando tar tiene mucha flexibilidad en su sintaxis.\nCómo extraer múltiples archivos de los archivos .tar En caso de que desees extraer varios archivos, usa el siguiente formato del commando:\n1 tar -xvf sampleArchive.tar \u0026#34;file1\u0026#34; \u0026#34;file2\u0026#34; Para .tar.gz puedes usar:\n1 tar -zxvf sampleArchive.tar.gz \u0026#34;file1\u0026#34; \u0026#34;file2\u0026#34; Para .tar.bz2 puedes usar:\n1 tar -jxvf sampleArchive.tar.bz2 \u0026#34;file1\u0026#34; \u0026#34;file2\u0026#34; Extraer múltiples archivos con un patrón Si deseas extraer del comprimido patrones específicos de archivos como solo los .jpg, usa el commando wildcards. Una muestra de dicho commando se muestra a continuación:\ntar -xvf sampleArchive.tar \u0026ndash;wildcards \u0026lsquo;*.jpg\u0026rsquo;\n1 Para **.tar.gz** puedes usar: tar -zxvf sampleArchive.tar.gz \u0026ndash;wildcards \u0026lsquo;*.jpg\u0026rsquo;\nPara .tar.bz2 puedes usar:\n1 tar -jxvf sampleArchive.tar.bz2 --wildcards \u0026#39;*.jpg\u0026#39; Cómo agregar archivos a un archivo .tar Si bien puedes extraer archivos específicos, también puedes agregar archivos nuevos a un archivo comprimido existente. Para hacerlo, debes usar la opción -r que significa agregar. El commando Tar puede agregar tanto archivos como directorios.\nA continuación se muestra un ejemplo en el que estamos agregando example.jpg al sampleArchive.tar existente.\ntar -rvf sampleArchive.tar example.jpg\nTambién podemos agregar un directorio. En el ejemplo que te mostramos a continuación, el directorio image_dir se agrega al archivo sampleArchive.tar\ntar -rvf sampleArchive.tar image_dir\nNo puedes agregar archivos o carpetas a comprimidos .tar.gz o .tar.bz2.\nCómo verificar un archivo .tar en Linux Usando Tar puedes verificar un archivo. Esta es una de las formas en que puedes hacerlo:\ntar -tvf sampleArchive.tar\nEsto no se puede aplicar en archivos .tar.gz o .tar.bz2.\nCómo verificar el tamaño del archivo en Linux Una vez que crees un archivo, puedes verificar su tamaño. Este se mostrará en KB (Kilobytes).\nA continuación te mostramos varios ejemplos del commando a usar para verificar el tamaño de diferentes tipos de archivos comprimidos:\ntar -czf - sampleArchive.tar | wc -c\ntar -czf - sampleArchive.tar.gz | wc -c\ntar -czf - sampleArchive.tar.bz2 | wc -c\n","date":"2025-12-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/c%C3%B3mo-usar-el-comando-tar-en-linux/","title":"Cómo Usar El Comando Tar En Linux"},{"content":"Nvim Es necesario compilarlo asi que primero instala\n1 sudo apt-get install git cmake Luego clona el repositorio, compila e instala. Tardará un rato.\n1 2 3 4 5 6 git clone https://github.com/neovim/neovim.git cd neovim make CMAKE_BUILD_TYPE=RelWithDebInfo cd build cpack -G DEB sudo dpkg -i nvim-linux64.deb Comprueba la versión con\n1 nvim --version Lazyvim Haz una copia de seguridad si es necesario\n1 2 3 4 5 6 7 # required mv ~/.config/nvim{,.bak} # optional but recommended mv ~/.local/share/nvim{,.bak} mv ~/.local/state/nvim{,.bak} mv ~/.cache/nvim{,.bak} Clona el repo\n1 git clone https://github.com/LazyVim/starter ~/.config/nvim Elimina la carpeta .git para poder usarlo como repositorio luego\n1 rm -rf ~/.config/nvim/.git Instala los siguientes paquetes opcionales 1 sudo apt install lazygit ripgrep fd-find fzf lua5.4:armhf luarocks # las versiones pueden variar con el tiempo Para manejar imagenes (creo) puedes usar una de estas tres terminales\nkitty wezterm ghostty Usa neovim y ejecuta el commando :LazyHealthpara comprobar errores\n","date":"2025-12-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/instala-lazyvim-en-raspberry/","title":"Instala Lazyvim En Raspberry"},{"content":" Se ha usado una raspberry 4 con raspbian y un lector NFC ACR122 para este proyecto\nInstalación Instala los paquetes necesarios\n1 sudo apt-get install libacsccid1 pcscd pcsc-tools Activa el demonio que leerá las tarjetas\n1 sudo systemctl enable — now pcscd.socket Añade estas lineas para desactivar los módulos nfc del kernel:\n1 2 3 4 sudo nano /etc/modprobe.d/blacklist.conf # Añade estas lineas al final install nfc /bin/false install pn533 /bin/false Ya te debería permitir leer tarjetas usando pcsc_scan.\nIdentificar tarjetas Con el siguiente script podrás obtener el UID de cada tarjeta que mas tarde necesitaremos para reaccionar a las mismas.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/usr/bin/env python3 # obtener_uid.py from smartcard.System import readers from smartcard.util import toHexString import time def obtener_uid(): try: # Obtener lista de lectores reader_list = readers() if not reader_list: print(\u0026#34;No se encontraron lectores NFC\u0026#34;) return reader = reader_list[0] # Usar el primer lector print(f\u0026#34;Usando lector: {reader}\u0026#34;) print(\u0026#34;Acerca una tarjeta al lector...\u0026#34;) while True: try: # Conectar a la tarjeta connection = reader.createConnection() connection.connect() # Comando APDU para obtener UID command = [0xFF, 0xCA, 0x00, 0x00, 0x00] data, sw1, sw2 = connection.transmit(command) if sw1 == 0x90 and sw2 == 0x00: uid = toHexString(data).replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) print(f\u0026#34;UID detectado: {uid}\u0026#34;) else: print(\u0026#34;Error al leer la tarjeta\u0026#34;) connection.disconnect() time.sleep(2) except Exception as e: time.sleep(0.5) continue except KeyboardInterrupt: print(\u0026#34;\\nSaliendo...\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: obtener_uid() Reaccionar a tarjetas Una vez detectadas, podemos editar el siguiente script modificando la parte en que se identifica cada tarjeta con la función a realizar.\nEn esta ocasión usaremos moodeaudio para reproducir música. Podemos usar el siguiente commando curl para manejar moodeaudio: curl -G -S -s --data-urlencode \u0026quot;cmd=REST_API_COMMAND\u0026quot; http://moode/command/\nPara reproducir un disco especifico usaremos curl -G -S -s --data-urlencode \u0026quot;cmd=play_item NAS/ruta/al/directorio\u0026quot; http://moode_url/command/ Ej: curl -G -S -s --data-urlencode \u0026quot;cmd=play_item NAS/moode/moode/M/Mogwai/\u0026quot; http://moode_url/command/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #!/usr/bin/env python3 # nfc_launcher.py from smartcard.System import readers from smartcard.util import toHexString import subprocess import time import os # Configuración de tarjetas y comandos TARJETAS_CONFIG = { \u0026#34;B2BA9C1E\u0026#34;: { \u0026#34;nombre\u0026#34;: \u0026#34;Tarjeta 1\u0026#34;, \u0026#34;comando\u0026#34;: [\u0026#34;touch\u0026#34;, \u0026#34;/home/pi/sonidos.txt\u0026#34;] }, \u0026#34;YYYYYYYY\u0026#34;: { # Reemplaza con el UID real de tu tarjeta 2 \u0026#34;nombre\u0026#34;: \u0026#34;Tarjeta 2\u0026#34;, \u0026#34;comando\u0026#34;: [\u0026#34;curl\u0026#34;, \u0026#34;/home/pi/script1.py\u0026#34;], # Ejemplo: ejecutar script }, \u0026#34;ZZZZZZZZ\u0026#34;: { # Reemplaza con el UID real de tu tarjeta 3 \u0026#34;nombre\u0026#34;: \u0026#34;Tarjeta 3\u0026#34;, \u0026#34;comando\u0026#34;: [\u0026#34;systemctl\u0026#34;, \u0026#34;restart\u0026#34;, \u0026#34;nginx\u0026#34;], # Ejemplo: reiniciar servicio } } def ejecutar_comando(comando): \u0026#34;\u0026#34;\u0026#34;Ejecuta un comando del sistema\u0026#34;\u0026#34;\u0026#34; try: resultado = subprocess.run(comando, capture_output=True, text=True) if resultado.returncode == 0: print(f\u0026#34;Comando ejecutado exitosamente: {\u0026#39; \u0026#39;.join(comando)}\u0026#34;) if resultado.stdout: print(f\u0026#34;Salida: {resultado.stdout}\u0026#34;) else: print(f\u0026#34;Error ejecutando comando: {resultado.stderr}\u0026#34;) except Exception as e: print(f\u0026#34;Error: {e}\u0026#34;) def monitorear_tarjetas(): \u0026#34;\u0026#34;\u0026#34;Monitorea continuamente las tarjetas NFC\u0026#34;\u0026#34;\u0026#34; try: # Obtener lista de lectores reader_list = readers() if not reader_list: print(\u0026#34;No se encontraron lectores NFC\u0026#34;) return reader = reader_list[0] print(f\u0026#34;Usando lector: {reader}\u0026#34;) print(\u0026#34;Esperando tarjetas... (Ctrl+C para salir)\u0026#34;) ultima_tarjeta = None tiempo_ultima_lectura = 0 while True: try: # Conectar a la tarjeta connection = reader.createConnection() connection.connect() # Obtener UID command = [0xFF, 0xCA, 0x00, 0x00, 0x00] data, sw1, sw2 = connection.transmit(command) if sw1 == 0x90 and sw2 == 0x00: uid = toHexString(data).replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) tiempo_actual = time.time() # Evitar ejecuciones múltiples de la misma tarjeta if (uid != ultima_tarjeta or tiempo_actual - tiempo_ultima_lectura \u0026gt; 3): print(f\u0026#34;Tarjeta detectada: {uid}\u0026#34;) if uid in TARJETAS_CONFIG: config = TARJETAS_CONFIG[uid] print(f\u0026#34;Ejecutando comando para {config[\u0026#39;nombre\u0026#39;]}\u0026#34;) ejecutar_comando(config[\u0026#39;comando\u0026#39;]) else: print(\u0026#34;Tarjeta no configurada\u0026#34;) ultima_tarjeta = uid tiempo_ultima_lectura = tiempo_actual connection.disconnect() time.sleep(0.5) except Exception as e: # La tarjeta se retiró o no hay tarjeta time.sleep(0.5) continue except KeyboardInterrupt: print(\u0026#34;\\nSaliendo...\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: monitorear_tarjetas() (Opcional) Crea imágenes para esas tarjetas Con este script podremos crear imagenes con el tamaño de las tarjetas (52mmx82mm): CARA A:\nPortada Artista Album Sello Fecha lanzamiento Género CARA B\nTracklist QR a wikipedia y genius 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 #!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; Generador de Tarjetas de Álbumes Crea dos imágenes verticales de 52x82mm para tarjetas de álbumes musicales. Cara A: Portada del disco + información del álbum Cara B: Lista de pistas Requisitos: - mutagen: para leer tags de archivos de música - Pillow: para generar imágenes - musicbrainzngs: para buscar información en MusicBrainz - requests: para descargar portadas \u0026#34;\u0026#34;\u0026#34; import os import sys import json import argparse from pathlib import Path from typing import Dict, List, Optional, Tuple import logging import colorsys from collections import Counter try: from mutagen import File from mutagen.id3 import ID3NoHeaderError except ImportError: print(\u0026#34;Error: mutagen no está instalado. Instala con: pip install mutagen\u0026#34;) sys.exit(1) try: from PIL import Image, ImageDraw, ImageFont from PIL.ImageColor import getrgb import PIL.ImageStat as ImageStat except ImportError: print(\u0026#34;Error: Pillow no está instalado. Instala con: pip install Pillow\u0026#34;) sys.exit(1) try: import musicbrainzngs # Silenciar los warnings innecesarios de musicbrainzngs musicbrainzngs.set_useragent(\u0026#34;AlbumCardGenerator\u0026#34;, \u0026#34;1.0\u0026#34;, \u0026#34;https://github.com/example/album-card-generator\u0026#34;) # Configurar logging de musicbrainzngs para que no muestre warnings menores musicbrainz_logger = logging.getLogger(\u0026#39;musicbrainzngs.musicbrainz\u0026#39;) musicbrainz_logger.setLevel(logging.WARNING) except ImportError: print(\u0026#34;Error: musicbrainzngs no está instalado. Instala con: pip install musicbrainzngs\u0026#34;) sys.exit(1) try: import requests # Silenciar warnings de requests requests.packages.urllib3.disable_warnings() requests_logger = logging.getLogger(\u0026#39;urllib3\u0026#39;) requests_logger.setLevel(logging.WARNING) except ImportError: print(\u0026#34;Error: requests no está instalado. Instala con: pip install requests\u0026#34;) sys.exit(1) try: import qrcode from qrcode.image.styledpil import StyledPilImage from qrcode.image.styles.moduledrawers import RoundedModuleDrawer except ImportError: print(\u0026#34;Error: qrcode no está instalado. Instala con: pip install qrcode[pil]\u0026#34;) sys.exit(1) # Configuración de logging logging.basicConfig(level=logging.INFO, format=\u0026#39;%(asctime)s - %(levelname)s - %(message)s\u0026#39;) logger = logging.getLogger(__name__) # Constantes de diseño (en píxeles a 300 DPI) DPI = 300 CARD_WIDTH_MM = 52 CARD_HEIGHT_MM = 82 COVER_SIZE_MM = 51 TEXT_AREA_HEIGHT_MM = 30 # Conversión de mm a píxeles CARD_WIDTH = int(CARD_WIDTH_MM * DPI / 25.4) # ~613 px CARD_HEIGHT = int(CARD_HEIGHT_MM * DPI / 25.4) # ~969 px COVER_SIZE = int(COVER_SIZE_MM * DPI / 25.4) # ~601 px TEXT_AREA_HEIGHT = int(TEXT_AREA_HEIGHT_MM * DPI / 25.4) # ~354 px # Colores WHITE = (255, 255, 255) BLACK = (0, 0, 0) GRAY_LIGHT = (230, 230, 230) GRAY_DARK = (80, 80, 80) class ColorAnalyzer: \u0026#34;\u0026#34;\u0026#34;Analizador de colores para extraer paletas de imágenes\u0026#34;\u0026#34;\u0026#34; @staticmethod def extract_dominant_color(image: Image.Image) -\u0026gt; Tuple[int, int, int]: \u0026#34;\u0026#34;\u0026#34;Extrae el color dominante de una imagen\u0026#34;\u0026#34;\u0026#34; try: # Redimensionar para análisis más rápido img = image.copy() img = img.resize((150, 150), Image.Resampling.LANCZOS) img = img.convert(\u0026#39;RGB\u0026#39;) # Método 1: Color más común pixels = list(img.getdata()) # Agrupar colores similares (reducir ruido) grouped_colors = [] for r, g, b in pixels: # Reducir precisión para agrupar colores similares r = (r // 10) * 10 g = (g // 10) * 10 b = (b // 10) * 10 grouped_colors.append((r, g, b)) # Contar frecuencias color_counter = Counter(grouped_colors) # Filtrar colores muy oscuros o muy claros (probablemente bordes) filtered_colors = [] for color, count in color_counter.most_common(20): r, g, b = color brightness = (r + g + b) / 3 # Evitar negro puro, blanco puro y grises muy extremos if 20 \u0026lt; brightness \u0026lt; 235: # Evitar colores muy desaturados (grises) max_val = max(r, g, b) min_val = min(r, g, b) saturation = (max_val - min_val) / max_val if max_val \u0026gt; 0 else 0 if saturation \u0026gt; 0.1 or brightness \u0026lt; 100: # Permitir colores oscuros aunque sean desaturados filtered_colors.append((color, count)) if filtered_colors: dominant_color = filtered_colors[0][0] else: # Fallback: usar estadísticas de imagen stat = ImageStat.Stat(img) dominant_color = tuple(int(c) for c in stat.mean) return dominant_color except Exception as e: logger.warning(f\u0026#34;Error extrayendo color dominante: {e}\u0026#34;) return (80, 80, 80) # Gris oscuro como fallback @staticmethod def get_contrast_color(bg_color: Tuple[int, int, int]) -\u0026gt; Tuple[int, int, int]: \u0026#34;\u0026#34;\u0026#34;Obtiene un color de texto que contraste bien con el fondo\u0026#34;\u0026#34;\u0026#34; r, g, b = bg_color # Calcular luminancia (brillo percibido) luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255 if luminance \u0026gt; 0.5: # Fondo claro -\u0026gt; texto oscuro return (40, 40, 40) else: # Fondo oscuro -\u0026gt; texto claro return (240, 240, 240) @staticmethod def get_secondary_color(bg_color: Tuple[int, int, int]) -\u0026gt; Tuple[int, int, int]: \u0026#34;\u0026#34;\u0026#34;Obtiene un color secundario para texto menos importante\u0026#34;\u0026#34;\u0026#34; primary = ColorAnalyzer.get_contrast_color(bg_color) r, g, b = primary # Hacer el color secundario un poco más sutil if sum(primary) \u0026gt; 400: # Color claro return (max(0, r - 60), max(0, g - 60), max(0, b - 60)) else: # Color oscuro return (min(255, r + 60), min(255, g + 60), min(255, b + 60)) @staticmethod def get_border_color(bg_color: Tuple[int, int, int]) -\u0026gt; Tuple[int, int, int]: \u0026#34;\u0026#34;\u0026#34;Obtiene un color sutil para bordes\u0026#34;\u0026#34;\u0026#34; r, g, b = bg_color # Calcular luminancia luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255 if luminance \u0026gt; 0.5: # Fondo claro -\u0026gt; borde más oscuro factor = 0.8 else: # Fondo oscuro -\u0026gt; borde más claro factor = 1.2 new_r = min(255, max(0, int(r * factor))) new_g = min(255, max(0, int(g * factor))) new_b = min(255, max(0, int(b * factor))) return (new_r, new_g, new_b) @staticmethod def enhance_color(color: Tuple[int, int, int], saturation_boost: float = 1.2) -\u0026gt; Tuple[int, int, int]: \u0026#34;\u0026#34;\u0026#34;Realza un color aumentando su saturación\u0026#34;\u0026#34;\u0026#34; r, g, b = [c / 255.0 for c in color] # Convertir a HSV h, s, v = colorsys.rgb_to_hsv(r, g, b) # Aumentar saturación s = min(1.0, s * saturation_boost) # Convertir de vuelta a RGB r, g, b = colorsys.hsv_to_rgb(h, s, v) return (int(r * 255), int(g * 255), int(b * 255)) class AlbumInfo: \u0026#34;\u0026#34;\u0026#34;Clase para almacenar información del álbum\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.artist = \u0026#34;\u0026#34; self.album = \u0026#34;\u0026#34; self.date = \u0026#34;\u0026#34; self.label = \u0026#34;\u0026#34; self.genres = [] self.tracks = [] self.mbid = \u0026#34;\u0026#34; self.artist_mbid = \u0026#34;\u0026#34; # Nuevo campo para MBID del artista self.cover_art_url = \u0026#34;\u0026#34; self.cover_image = None self.color_palette = { \u0026#39;background\u0026#39;: (255, 255, 255), \u0026#39;text_primary\u0026#39;: (0, 0, 0), \u0026#39;text_secondary\u0026#39;: (80, 80, 80), \u0026#39;border\u0026#39;: (230, 230, 230) } self.qr_links = { \u0026#39;wikipedia_artist\u0026#39;: \u0026#34;\u0026#34;, \u0026#39;genius_album\u0026#39;: \u0026#34;\u0026#34; } class QRLinkGenerator: \u0026#34;\u0026#34;\u0026#34;Generador de enlaces para códigos QR\u0026#34;\u0026#34;\u0026#34; @staticmethod def get_wikipedia_from_musicbrainz(artist_mbid: str) -\u0026gt; Optional[str]: \u0026#34;\u0026#34;\u0026#34;Obtiene el enlace de Wikipedia desde Wikidata a través de MusicBrainz\u0026#34;\u0026#34;\u0026#34; try: logger.info(f\u0026#34;Buscando Wikipedia en MusicBrainz para MBID: {artist_mbid}\u0026#34;) # Obtener información del artista desde MusicBrainz incluyendo Wikidata result = musicbrainzngs.get_artist_by_id(artist_mbid, includes=[\u0026#39;url-rels\u0026#39;]) if \u0026#39;artist\u0026#39; not in result: return None artist = result[\u0026#39;artist\u0026#39;] # Buscar relaciones de URL, especialmente Wikidata wikidata_url = None wikipedia_urls = {} if \u0026#39;url-relation-list\u0026#39; in artist: for url_rel in artist[\u0026#39;url-relation-list\u0026#39;]: url = url_rel.get(\u0026#39;target\u0026#39;, \u0026#39;\u0026#39;) rel_type = url_rel.get(\u0026#39;type\u0026#39;, \u0026#39;\u0026#39;) # Enlace directo a Wikipedia if \u0026#39;wikipedia.org\u0026#39; in url: if \u0026#39;/es.wikipedia.org/\u0026#39; in url: wikipedia_urls[\u0026#39;es\u0026#39;] = url elif \u0026#39;/en.wikipedia.org/\u0026#39; in url: wikipedia_urls[\u0026#39;en\u0026#39;] = url else: # Otros idiomas lang = url.split(\u0026#39;.\u0026#39;)[0].split(\u0026#39;//\u0026#39;)[-1] wikipedia_urls[lang] = url # Enlace de Wikidata elif \u0026#39;wikidata.org\u0026#39; in url and rel_type == \u0026#39;wikidata\u0026#39;: wikidata_url = url # Preferir enlaces directos de Wikipedia (español \u0026gt; inglés \u0026gt; otros) if \u0026#39;es\u0026#39; in wikipedia_urls: logger.info(f\u0026#34;Encontrada Wikipedia directa en español: {wikipedia_urls[\u0026#39;es\u0026#39;]}\u0026#34;) return wikipedia_urls[\u0026#39;es\u0026#39;] elif \u0026#39;en\u0026#39; in wikipedia_urls: logger.info(f\u0026#34;Encontrada Wikipedia directa en inglés: {wikipedia_urls[\u0026#39;en\u0026#39;]}\u0026#34;) return wikipedia_urls[\u0026#39;en\u0026#39;] elif wikipedia_urls: # Tomar el primer idioma disponible first_lang = next(iter(wikipedia_urls)) logger.info(f\u0026#34;Encontrada Wikipedia en {first_lang}: {wikipedia_urls[first_lang]}\u0026#34;) return wikipedia_urls[first_lang] # Si no hay enlaces directos pero hay Wikidata, intentar obtener Wikipedia desde ahí if wikidata_url: wiki_from_wikidata = QRLinkGenerator._get_wikipedia_from_wikidata(wikidata_url) if wiki_from_wikidata: return wiki_from_wikidata except Exception as e: logger.warning(f\u0026#34;Error obteniendo Wikipedia desde MusicBrainz: {e}\u0026#34;) return None @staticmethod def _get_wikipedia_from_wikidata(wikidata_url: str) -\u0026gt; Optional[str]: \u0026#34;\u0026#34;\u0026#34;Obtiene enlaces de Wikipedia desde Wikidata\u0026#34;\u0026#34;\u0026#34; try: # Extraer Q-ID de Wikidata qid = wikidata_url.split(\u0026#39;/\u0026#39;)[-1] if not qid.startswith(\u0026#39;Q\u0026#39;): return None logger.info(f\u0026#34;Consultando Wikidata para {qid}\u0026#34;) # Consulta SPARQL a Wikidata para obtener enlaces de Wikipedia sparql_query = f\u0026#34;\u0026#34;\u0026#34; SELECT ?article ?lang WHERE {{ ?article schema:about wd:{qid} ; schema:inLanguage ?lang ; schema:isPartOf ?wiki . ?wiki wikibase:wikiGroup \u0026#34;wikipedia\u0026#34; . FILTER(?lang IN (\u0026#34;es\u0026#34;, \u0026#34;en\u0026#34;)) }} ORDER BY DESC(?lang = \u0026#34;es\u0026#34;) LIMIT 2 \u0026#34;\u0026#34;\u0026#34; # Hacer petición a Wikidata sparql_endpoint = \u0026#34;https://query.wikidata.org/sparql\u0026#34; headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;AlbumCardGenerator/1.0\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;application/json\u0026#39; } response = requests.get( sparql_endpoint, params={\u0026#39;query\u0026#39;: sparql_query, \u0026#39;format\u0026#39;: \u0026#39;json\u0026#39;}, headers=headers, timeout=10 ) if response.status_code == 200: data = response.json() results = data.get(\u0026#39;results\u0026#39;, {}).get(\u0026#39;bindings\u0026#39;, []) for result in results: url = result.get(\u0026#39;article\u0026#39;, {}).get(\u0026#39;value\u0026#39;, \u0026#39;\u0026#39;) lang = result.get(\u0026#39;lang\u0026#39;, {}).get(\u0026#39;value\u0026#39;, \u0026#39;\u0026#39;) if url and lang: logger.info(f\u0026#34;Encontrada Wikipedia desde Wikidata ({lang}): {url}\u0026#34;) return url except Exception as e: logger.warning(f\u0026#34;Error consultando Wikidata: {e}\u0026#34;) return None @staticmethod def search_wikipedia_artist(artist_name: str, artist_mbid: str = None) -\u0026gt; Optional[str]: \u0026#34;\u0026#34;\u0026#34;Busca el enlace de Wikipedia del artista\u0026#34;\u0026#34;\u0026#34; try: logger.info(f\u0026#34;Buscando Wikipedia para: {artist_name}\u0026#34;) # Primero intentar con MusicBrainz/Wikidata si tenemos MBID if artist_mbid: mb_wikipedia = QRLinkGenerator.get_wikipedia_from_musicbrainz(artist_mbid) if mb_wikipedia: return mb_wikipedia # Método de respaldo: búsqueda directa por nombre logger.info(\u0026#34;Intentando búsqueda directa por nombre del artista\u0026#34;) # Limpiar nombre del artista para búsqueda clean_artist = artist_name.replace(\u0026#34; \u0026#34;, \u0026#34;_\u0026#34;).replace(\u0026#34;\u0026amp;\u0026#34;, \u0026#34;and\u0026#34;) # URL directa de Wikipedia en español wiki_url_es = f\u0026#34;https://es.wikipedia.org/wiki/{clean_artist}\u0026#34; # Verificar si existe la página en español response = requests.head(wiki_url_es, timeout=5) if response.status_code == 200: logger.info(f\u0026#34;Encontrada Wikipedia en español: {wiki_url_es}\u0026#34;) return wiki_url_es # Si no existe en español, probar en inglés wiki_url_en = f\u0026#34;https://en.wikipedia.org/wiki/{clean_artist}\u0026#34; response = requests.head(wiki_url_en, timeout=5) if response.status_code == 200: logger.info(f\u0026#34;Encontrada Wikipedia en inglés: {wiki_url_en}\u0026#34;) return wiki_url_en # Buscar usando la API de Wikipedia search_url = \u0026#34;https://es.wikipedia.org/api/rest_v1/page/title\u0026#34; params = { \u0026#39;q\u0026#39;: artist_name, \u0026#39;limit\u0026#39;: 1 } response = requests.get(search_url, params=params, timeout=5) if response.status_code == 200: data = response.json() if data.get(\u0026#39;pages\u0026#39;): page_title = data[\u0026#39;pages\u0026#39;][0][\u0026#39;title\u0026#39;] wiki_url = f\u0026#34;https://es.wikipedia.org/wiki/{page_title.replace(\u0026#39; \u0026#39;, \u0026#39;_\u0026#39;)}\u0026#34; logger.info(f\u0026#34;Encontrada Wikipedia por búsqueda: {wiki_url}\u0026#34;) return wiki_url except Exception as e: logger.warning(f\u0026#34;Error buscando Wikipedia para {artist_name}: {e}\u0026#34;) return None @staticmethod def search_genius_album(artist_name: str, album_name: str) -\u0026gt; Optional[str]: \u0026#34;\u0026#34;\u0026#34;Busca el enlace de Genius del álbum\u0026#34;\u0026#34;\u0026#34; try: logger.info(f\u0026#34;Buscando Genius para: {artist_name} - {album_name}\u0026#34;) # Limpiar nombres para URL clean_artist = artist_name.lower().replace(\u0026#34; \u0026#34;, \u0026#34;-\u0026#34;).replace(\u0026#34;\u0026amp;\u0026#34;, \u0026#34;and\u0026#34;) clean_album = album_name.lower().replace(\u0026#34; \u0026#34;, \u0026#34;-\u0026#34;).replace(\u0026#34;\u0026amp;\u0026#34;, \u0026#34;and\u0026#34;) # Remover caracteres especiales import re clean_artist = re.sub(r\u0026#39;[^\\w\\-]\u0026#39;, \u0026#39;\u0026#39;, clean_artist) clean_album = re.sub(r\u0026#39;[^\\w\\-]\u0026#39;, \u0026#39;\u0026#39;, clean_album) # URL típica de Genius para álbumes genius_url = f\u0026#34;https://genius.com/albums/{clean_artist}/{clean_album}\u0026#34; # Verificar si existe la página try: response = requests.head(genius_url, timeout=5, allow_redirects=True) if response.status_code == 200: logger.info(f\u0026#34;Encontrado Genius: {genius_url}\u0026#34;) return genius_url except: pass # Formato alternativo genius_url_alt = f\u0026#34;https://genius.com/{clean_artist}-{clean_album}-album\u0026#34; try: response = requests.head(genius_url_alt, timeout=5, allow_redirects=True) if response.status_code == 200: logger.info(f\u0026#34;Encontrado Genius (formato alternativo): {genius_url_alt}\u0026#34;) return genius_url_alt except: pass # Si no se encuentra, generar URL de búsqueda search_query = f\u0026#34;{artist_name} {album_name}\u0026#34;.replace(\u0026#34; \u0026#34;, \u0026#34;%20\u0026#34;) search_url = f\u0026#34;https://genius.com/search?q={search_query}\u0026#34; logger.info(f\u0026#34;Generando URL de búsqueda Genius: {search_url}\u0026#34;) return search_url except Exception as e: logger.warning(f\u0026#34;Error buscando Genius para {artist_name} - {album_name}: {e}\u0026#34;) return None @staticmethod def generate_qr_links(album_info: AlbumInfo): \u0026#34;\u0026#34;\u0026#34;Genera los enlaces para los códigos QR\u0026#34;\u0026#34;\u0026#34; try: # Buscar Wikipedia del artista (usando MBID si está disponible) if album_info.artist: wikipedia_link = QRLinkGenerator.search_wikipedia_artist( album_info.artist, album_info.artist_mbid ) if wikipedia_link: album_info.qr_links[\u0026#39;wikipedia_artist\u0026#39;] = wikipedia_link # Buscar Genius del álbum if album_info.artist and album_info.album: genius_link = QRLinkGenerator.search_genius_album(album_info.artist, album_info.album) if genius_link: album_info.qr_links[\u0026#39;genius_album\u0026#39;] = genius_link except Exception as e: logger.warning(f\u0026#34;Error generando enlaces QR: {e}\u0026#34;) class QRCodeGenerator: \u0026#34;\u0026#34;\u0026#34;Generador de códigos QR\u0026#34;\u0026#34;\u0026#34; @staticmethod def create_qr_code(url: str, size: int = 120, bg_color: Tuple[int, int, int] = (255, 255, 255), fg_color: Tuple[int, int, int] = (0, 0, 0)) -\u0026gt; Optional[Image.Image]: \u0026#34;\u0026#34;\u0026#34;Crea un código QR con los colores especificados y máximo contraste\u0026#34;\u0026#34;\u0026#34; try: # Optimizar colores para máximo contraste optimized_bg, optimized_fg = QRCodeGenerator._optimize_qr_colors(bg_color, fg_color) # Configurar QR code qr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_M, box_size=4, # Aumentado para mejor definición border=1, ) qr.add_data(url) qr.make(fit=True) # Crear imagen del QR qr_img = qr.make_image( fill_color=optimized_fg, back_color=optimized_bg, image_factory=StyledPilImage, module_drawer=RoundedModuleDrawer() ) # Redimensionar al tamaño deseado qr_img = qr_img.resize((size, size), Image.Resampling.LANCZOS) return qr_img except Exception as e: logger.warning(f\u0026#34;Error creando código QR para {url}: {e}\u0026#34;) return None @staticmethod def _optimize_qr_colors(bg_color: Tuple[int, int, int], fg_color: Tuple[int, int, int]) -\u0026gt; Tuple[Tuple[int, int, int], Tuple[int, int, int]]: \u0026#34;\u0026#34;\u0026#34;Optimiza los colores del QR para máximo contraste\u0026#34;\u0026#34;\u0026#34; # Calcular luminancia del fondo bg_luminance = (0.299 * bg_color[0] + 0.587 * bg_color[1] + 0.114 * bg_color[2]) / 255 # Si el fondo es muy claro, asegurar QR oscuro if bg_luminance \u0026gt; 0.6: # Fondo claro -\u0026gt; QR muy oscuro para máximo contraste optimized_fg = (20, 20, 20) # Casi negro optimized_bg = bg_color # Si el fondo es muy oscuro, asegurar QR claro elif bg_luminance \u0026lt; 0.4: # Fondo oscuro -\u0026gt; QR muy claro para máximo contraste optimized_fg = (240, 240, 240) # Casi blanco optimized_bg = bg_color # Para fondos intermedios, usar colores dados pero ajustados else: # Ajustar para garantizar contraste mínimo if bg_luminance \u0026gt; 0.5: optimized_fg = (30, 30, 30) # Oscuro else: optimized_fg = (225, 225, 225) # Claro optimized_bg = bg_color return optimized_bg, optimized_fg class MusicFileProcessor: \u0026#34;\u0026#34;\u0026#34;Procesador de archivos de música\u0026#34;\u0026#34;\u0026#34; def __init__(self, folder_path: str): self.folder_path = Path(folder_path) self.supported_formats = {\u0026#39;.mp3\u0026#39;, \u0026#39;.flac\u0026#39;, \u0026#39;.ogg\u0026#39;, \u0026#39;.mp4\u0026#39;, \u0026#39;.m4a\u0026#39;, \u0026#39;.wv\u0026#39;} def get_audio_files(self) -\u0026gt; List[Path]: \u0026#34;\u0026#34;\u0026#34;Obtiene todos los archivos de audio de la carpeta\u0026#34;\u0026#34;\u0026#34; audio_files = [] for file_path in self.folder_path.rglob(\u0026#39;*\u0026#39;): if file_path.suffix.lower() in self.supported_formats: audio_files.append(file_path) # Ordenar por nombre de archivo audio_files.sort() return audio_files def extract_album_info(self, audio_files: List[Path]) -\u0026gt; AlbumInfo: \u0026#34;\u0026#34;\u0026#34;Extrae información del álbum desde los archivos de audio\u0026#34;\u0026#34;\u0026#34; album_info = AlbumInfo() if not audio_files: raise ValueError(\u0026#34;No se encontraron archivos de audio\u0026#34;) # Procesar el primer archivo para obtener información general del álbum first_file = audio_files[0] try: audio_file = File(first_file) if audio_file is None: raise ValueError(f\u0026#34;No se pudo leer el archivo: {first_file}\u0026#34;) # Extraer información básica album_info.artist = self._get_tag(audio_file, \u0026#39;artist\u0026#39;, \u0026#39;albumartist\u0026#39;, \u0026#39;TPE1\u0026#39;, \u0026#39;TPE2\u0026#39;) album_info.album = self._get_tag(audio_file, \u0026#39;album\u0026#39;, \u0026#39;TALB\u0026#39;) album_info.date = self._get_tag(audio_file, \u0026#39;date\u0026#39;, \u0026#39;year\u0026#39;, \u0026#39;TDRC\u0026#39;) album_info.label = self._get_tag(audio_file, \u0026#39;label\u0026#39;, \u0026#39;publisher\u0026#39;, \u0026#39;TPUB\u0026#39;) # Géneros genre_tag = self._get_tag(audio_file, \u0026#39;genre\u0026#39;, \u0026#39;TCON\u0026#39;) if genre_tag: album_info.genres = [g.strip() for g in genre_tag.split(\u0026#39;,\u0026#39;)] # MBID album_info.mbid = self._get_tag(audio_file, \u0026#39;musicbrainz_albumid\u0026#39;, \u0026#39;TXXX:MusicBrainz Album Id\u0026#39;) # MBID del artista album_info.artist_mbid = self._get_tag(audio_file, \u0026#39;musicbrainz_artistid\u0026#39;, \u0026#39;TXXX:MusicBrainz Artist Id\u0026#39;) except Exception as e: logger.warning(f\u0026#34;Error procesando {first_file}: {e}\u0026#34;) # Procesar todas las pistas for file_path in audio_files: try: audio_file = File(file_path) if audio_file is None: continue track_number = self._get_tag(audio_file, \u0026#39;tracknumber\u0026#39;, \u0026#39;track\u0026#39;, \u0026#39;TRCK\u0026#39;) title = self._get_tag(audio_file, \u0026#39;title\u0026#39;, \u0026#39;TIT2\u0026#39;) # Limpiar número de pista (remover \u0026#34;1/10\u0026#34; -\u0026gt; \u0026#34;1\u0026#34;) if track_number and \u0026#39;/\u0026#39; in track_number: track_number = track_number.split(\u0026#39;/\u0026#39;)[0] track_info = { \u0026#39;number\u0026#39;: int(track_number) if track_number and track_number.isdigit() else len(album_info.tracks) + 1, \u0026#39;title\u0026#39;: title or file_path.stem, \u0026#39;file\u0026#39;: file_path } album_info.tracks.append(track_info) except Exception as e: logger.warning(f\u0026#34;Error procesando pista {file_path}: {e}\u0026#34;) # Ordenar pistas por número album_info.tracks.sort(key=lambda x: x[\u0026#39;number\u0026#39;]) return album_info def _get_tag(self, audio_file, *tag_names) -\u0026gt; Optional[str]: \u0026#34;\u0026#34;\u0026#34;Obtiene el valor de un tag, probando múltiples nombres\u0026#34;\u0026#34;\u0026#34; for tag_name in tag_names: try: if tag_name in audio_file: value = audio_file[tag_name] if isinstance(value, list) and value: return str(value[0]).strip() elif value: return str(value).strip() except (KeyError, AttributeError): continue return None class MusicBrainzEnricher: \u0026#34;\u0026#34;\u0026#34;Enriquece la información del álbum usando MusicBrainz\u0026#34;\u0026#34;\u0026#34; def enrich_album_info(self, album_info: AlbumInfo) -\u0026gt; AlbumInfo: \u0026#34;\u0026#34;\u0026#34;Enriquece la información del álbum\u0026#34;\u0026#34;\u0026#34; # Intentar con MBID primero if album_info.mbid: enriched = self._get_info_by_mbid(album_info) if enriched: album_info = enriched # Si no tiene MBID o no se encontró, buscar por artista y álbum elif album_info.artist and album_info.album: enriched = self._search_by_artist_album(album_info) if enriched: album_info = enriched # Generar enlaces para códigos QR logger.info(\u0026#34;Generando enlaces para códigos QR...\u0026#34;) QRLinkGenerator.generate_qr_links(album_info) if not album_info.artist or not album_info.album: logger.warning(\u0026#34;No se pudo enriquecer la información desde MusicBrainz\u0026#34;) return album_info def _get_info_by_mbid(self, album_info: AlbumInfo) -\u0026gt; Optional[AlbumInfo]: \u0026#34;\u0026#34;\u0026#34;Obtiene información usando el MBID\u0026#34;\u0026#34;\u0026#34; try: result = musicbrainzngs.get_release_by_id( album_info.mbid, includes=[\u0026#39;artist-credits\u0026#39;, \u0026#39;release-groups\u0026#39;, \u0026#39;labels\u0026#39;, \u0026#39;recordings\u0026#39;] ) return self._parse_musicbrainz_result(result[\u0026#39;release\u0026#39;], album_info) except Exception as e: logger.warning(f\u0026#34;Error consultando MusicBrainz por MBID {album_info.mbid}: {e}\u0026#34;) return None def _search_by_artist_album(self, album_info: AlbumInfo) -\u0026gt; Optional[AlbumInfo]: \u0026#34;\u0026#34;\u0026#34;Busca información por artista y álbum\u0026#34;\u0026#34;\u0026#34; try: results = musicbrainzngs.search_releases( artist=album_info.artist, release=album_info.album, limit=5 ) if results[\u0026#39;release-list\u0026#39;]: # Tomar el primer resultado release = results[\u0026#39;release-list\u0026#39;][0] # Obtener información completa detailed_result = musicbrainzngs.get_release_by_id( release[\u0026#39;id\u0026#39;], includes=[\u0026#39;artist-credits\u0026#39;, \u0026#39;release-groups\u0026#39;, \u0026#39;labels\u0026#39;, \u0026#39;recordings\u0026#39;] ) return self._parse_musicbrainz_result(detailed_result[\u0026#39;release\u0026#39;], album_info) except Exception as e: logger.warning(f\u0026#34;Error buscando en MusicBrainz: {e}\u0026#34;) return None def _parse_musicbrainz_result(self, release, original_info: AlbumInfo) -\u0026gt; AlbumInfo: \u0026#34;\u0026#34;\u0026#34;Parsea el resultado de MusicBrainz\u0026#34;\u0026#34;\u0026#34; enriched = AlbumInfo() # Mantener información original como fallback enriched.artist = original_info.artist enriched.album = original_info.album enriched.tracks = original_info.tracks enriched.genres = original_info.genres # Enriquecer con datos de MusicBrainz try: # Artista if \u0026#39;artist-credit\u0026#39; in release and release[\u0026#39;artist-credit\u0026#39;]: artist_names = [] artist_mbids = [] for ac in release[\u0026#39;artist-credit\u0026#39;]: if \u0026#39;artist\u0026#39; in ac: artist_names.append(ac[\u0026#39;artist\u0026#39;][\u0026#39;name\u0026#39;]) # Extraer MBID del artista if \u0026#39;id\u0026#39; in ac[\u0026#39;artist\u0026#39;]: artist_mbids.append(ac[\u0026#39;artist\u0026#39;][\u0026#39;id\u0026#39;]) if artist_names: enriched.artist = \u0026#39;, \u0026#39;.join(artist_names) if artist_mbids: enriched.artist_mbid = artist_mbids[0] # Usar el primer artista # Álbum if \u0026#39;title\u0026#39; in release: enriched.album = release[\u0026#39;title\u0026#39;] # Fecha if \u0026#39;date\u0026#39; in release: enriched.date = release[\u0026#39;date\u0026#39;] elif original_info.date: enriched.date = original_info.date # Sello discográfico if \u0026#39;label-info-list\u0026#39; in release and release[\u0026#39;label-info-list\u0026#39;]: labels = [] for label_info in release[\u0026#39;label-info-list\u0026#39;]: if \u0026#39;label\u0026#39; in label_info and \u0026#39;name\u0026#39; in label_info[\u0026#39;label\u0026#39;]: labels.append(label_info[\u0026#39;label\u0026#39;][\u0026#39;name\u0026#39;]) if labels: enriched.label = \u0026#39;, \u0026#39;.join(labels) elif original_info.label: enriched.label = original_info.label # Géneros (desde release-group) if \u0026#39;release-group\u0026#39; in release and \u0026#39;tag-list\u0026#39; in release[\u0026#39;release-group\u0026#39;]: genres = [tag[\u0026#39;name\u0026#39;] for tag in release[\u0026#39;release-group\u0026#39;][\u0026#39;tag-list\u0026#39;]] if genres: enriched.genres = genres # MBID enriched.mbid = release[\u0026#39;id\u0026#39;] # URL de portada (Cover Art Archive) enriched.cover_art_url = f\u0026#34;https://coverartarchive.org/release/{release[\u0026#39;id\u0026#39;]}/front\u0026#34; except Exception as e: logger.warning(f\u0026#34;Error parseando resultado de MusicBrainz: {e}\u0026#34;) return enriched class CoverArtDownloader: \u0026#34;\u0026#34;\u0026#34;Descargador de portadas de álbumes\u0026#34;\u0026#34;\u0026#34; def download_cover(self, album_info: AlbumInfo) -\u0026gt; Optional[Image.Image]: \u0026#34;\u0026#34;\u0026#34;Descarga la portada del álbum y extrae la paleta de colores\u0026#34;\u0026#34;\u0026#34; cover_image = None # Intentar desde Cover Art Archive si tenemos MBID if album_info.cover_art_url: cover_image = self._download_from_url(album_info.cover_art_url) # Buscar archivo de imagen en la carpeta si no se descargó if not cover_image and album_info.tracks: folder_path = Path(album_info.tracks[0][\u0026#39;file\u0026#39;]).parent cover_image = self._find_local_cover(folder_path) # Crear portada por defecto si no se encontró ninguna if not cover_image: cover_image = self._create_default_cover(album_info) # Extraer paleta de colores de la portada if cover_image: self._extract_color_palette(album_info, cover_image) return cover_image def _extract_color_palette(self, album_info: AlbumInfo, cover_image: Image.Image): \u0026#34;\u0026#34;\u0026#34;Extrae la paleta de colores de la portada\u0026#34;\u0026#34;\u0026#34; try: logger.info(\u0026#34;Extrayendo paleta de colores de la portada...\u0026#34;) # Extraer color dominante dominant_color = ColorAnalyzer.extract_dominant_color(cover_image) # Realzar el color para el fondo enhanced_bg = ColorAnalyzer.enhance_color(dominant_color, saturation_boost=0.8) # Generar paleta completa album_info.color_palette = { \u0026#39;background\u0026#39;: enhanced_bg, \u0026#39;text_primary\u0026#39;: ColorAnalyzer.get_contrast_color(enhanced_bg), \u0026#39;text_secondary\u0026#39;: ColorAnalyzer.get_secondary_color(enhanced_bg), \u0026#39;border\u0026#39;: ColorAnalyzer.get_border_color(enhanced_bg) } logger.info(f\u0026#34;Paleta extraída - Fondo: {enhanced_bg}, Texto: {album_info.color_palette[\u0026#39;text_primary\u0026#39;]}\u0026#34;) except Exception as e: logger.warning(f\u0026#34;Error extrayendo paleta de colores: {e}\u0026#34;) # Mantener paleta por defecto album_info.color_palette = { \u0026#39;background\u0026#39;: (255, 255, 255), \u0026#39;text_primary\u0026#39;: (0, 0, 0), \u0026#39;text_secondary\u0026#39;: (80, 80, 80), \u0026#39;border\u0026#39;: (230, 230, 230) } def _download_from_url(self, url: str) -\u0026gt; Optional[Image.Image]: \u0026#34;\u0026#34;\u0026#34;Descarga imagen desde URL\u0026#34;\u0026#34;\u0026#34; try: response = requests.get(url, timeout=10) response.raise_for_status() image = Image.open(requests.get(url, stream=True).raw) return image except Exception as e: logger.warning(f\u0026#34;Error descargando portada desde {url}: {e}\u0026#34;) return None def _find_local_cover(self, folder_path: Path) -\u0026gt; Optional[Image.Image]: \u0026#34;\u0026#34;\u0026#34;Busca archivos de imagen en la carpeta\u0026#34;\u0026#34;\u0026#34; cover_names = [\u0026#39;cover\u0026#39;, \u0026#39;folder\u0026#39;, \u0026#39;front\u0026#39;, \u0026#39;album\u0026#39;] image_extensions = [\u0026#39;.jpg\u0026#39;, \u0026#39;.jpeg\u0026#39;, \u0026#39;.png\u0026#39;, \u0026#39;.bmp\u0026#39;, \u0026#39;.tiff\u0026#39;] # Buscar archivos específicos for cover_name in cover_names: for ext in image_extensions: cover_file = folder_path / f\u0026#34;{cover_name}{ext}\u0026#34; if cover_file.exists(): try: return Image.open(cover_file) except Exception as e: logger.warning(f\u0026#34;Error abriendo imagen {cover_file}: {e}\u0026#34;) # Buscar cualquier imagen for file_path in folder_path.iterdir(): if file_path.suffix.lower() in image_extensions: try: return Image.open(file_path) except Exception as e: logger.warning(f\u0026#34;Error abriendo imagen {file_path}: {e}\u0026#34;) return None def _create_default_cover(self, album_info: AlbumInfo) -\u0026gt; Image.Image: \u0026#34;\u0026#34;\u0026#34;Crea una portada por defecto con colores mejorados\u0026#34;\u0026#34;\u0026#34; size = 500 # Colores base más atractivos base_colors = [ (45, 55, 72), # Azul gris oscuro (68, 51, 122), # Púrpura (31, 81, 89), # Verde azulado (120, 53, 15), # Marrón cálido (74, 29, 30), # Rojo oscuro (45, 74, 60), # Verde oscuro ] # Elegir color base según el nombre del álbum color_index = sum(ord(c) for c in (album_info.album or \u0026#34;default\u0026#34;)) % len(base_colors) base_color = base_colors[color_index] # Crear imagen con gradiente image = Image.new(\u0026#39;RGB\u0026#39;, (size, size), base_color) draw = ImageDraw.Draw(image) # Gradiente sutil for y in range(size): ratio = y / size r, g, b = base_color # Crear variación tonal new_r = max(0, min(255, int(r + ratio * 30 - 15))) new_g = max(0, min(255, int(g + ratio * 30 - 15))) new_b = max(0, min(255, int(b + ratio * 30 - 15))) draw.line([(0, y), (size, y)], fill=(new_r, new_g, new_b)) # Añadir patrón geométrico sutil pattern_color = tuple(min(255, c + 20) for c in base_color) # Círculos concéntricos center = size // 2 for radius in range(50, 200, 40): draw.ellipse([ center - radius, center - radius, center + radius, center + radius ], outline=pattern_color, width=2) # Texto con mejor tipografía try: title_font = ImageFont.truetype(\u0026#34;/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\u0026#34;, 40) artist_font = ImageFont.truetype(\u0026#34;/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\u0026#34;, 30) except: title_font = ImageFont.load_default() artist_font = ImageFont.load_default() # Colores de texto contrastantes text_color = ColorAnalyzer.get_contrast_color(base_color) shadow_color = tuple(c // 3 for c in text_color) # Texto del álbum album_text = (album_info.album or \u0026#34;Album\u0026#34;).upper() artist_text = (album_info.artist or \u0026#34;Artist\u0026#34;).upper() # Posicionar texto del álbum bbox = draw.textbbox((0, 0), album_text, font=title_font) text_width = bbox[2] - bbox[0] x = (size - text_width) // 2 y = int(size * 0.7) # Sombra sutil draw.text((x + 2, y + 2), album_text, fill=shadow_color, font=title_font) draw.text((x, y), album_text, fill=text_color, font=title_font) # Texto del artista bbox = draw.textbbox((0, 0), artist_text, font=artist_font) text_width = bbox[2] - bbox[0] x = (size - text_width) // 2 y += 50 draw.text((x + 1, y + 1), artist_text, fill=shadow_color, font=artist_font) draw.text((x, y), artist_text, fill=text_color, font=artist_font) return image class CardGenerator: \u0026#34;\u0026#34;\u0026#34;Generador de tarjetas de álbumes\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.setup_fonts() def setup_fonts(self): \u0026#34;\u0026#34;\u0026#34;Configura las fuentes\u0026#34;\u0026#34;\u0026#34; self.fonts = {} font_paths = [ \u0026#34;/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\u0026#34;, \u0026#34;/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\u0026#34;, \u0026#34;/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf\u0026#34;, \u0026#34;/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf\u0026#34;, ] for font_path in font_paths: if os.path.exists(font_path): try: self.fonts[\u0026#39;title\u0026#39;] = ImageFont.truetype(font_path, 32) self.fonts[\u0026#39;artist\u0026#39;] = ImageFont.truetype(font_path, 28) self.fonts[\u0026#39;info\u0026#39;] = ImageFont.truetype(font_path, 20) self.fonts[\u0026#39;track\u0026#39;] = ImageFont.truetype(font_path, 18) break except Exception: continue # Fallback a fuente por defecto if not self.fonts: self.fonts = { \u0026#39;title\u0026#39;: ImageFont.load_default(), \u0026#39;artist\u0026#39;: ImageFont.load_default(), \u0026#39;info\u0026#39;: ImageFont.load_default(), \u0026#39;track\u0026#39;: ImageFont.load_default(), } def generate_front_card(self, album_info: AlbumInfo) -\u0026gt; Image.Image: \u0026#34;\u0026#34;\u0026#34;Genera la cara A (frontal) de la tarjeta con colores dinámicos\u0026#34;\u0026#34;\u0026#34; # Obtener paleta de colores bg_color = album_info.color_palette[\u0026#39;background\u0026#39;] text_primary = album_info.color_palette[\u0026#39;text_primary\u0026#39;] text_secondary = album_info.color_palette[\u0026#39;text_secondary\u0026#39;] border_color = album_info.color_palette[\u0026#39;border\u0026#39;] # Crear imagen base con color de fondo dinámico image = Image.new(\u0026#39;RGB\u0026#39;, (CARD_WIDTH, CARD_HEIGHT), bg_color) draw = ImageDraw.Draw(image) # Área de la portada (51x51mm en la parte superior) cover_y = 10 cover_x = (CARD_WIDTH - COVER_SIZE) // 2 # Redimensionar y colocar portada if album_info.cover_image: cover = album_info.cover_image.resize((COVER_SIZE, COVER_SIZE), Image.Resampling.LANCZOS) image.paste(cover, (cover_x, cover_y)) # Marco sutil para la portada frame_color = ColorAnalyzer.get_border_color(bg_color) draw.rectangle([ cover_x - 2, cover_y - 2, cover_x + COVER_SIZE + 2, cover_y + COVER_SIZE + 2 ], outline=frame_color, width=3) # Área de texto (30mm en la parte inferior) text_y_start = cover_y + COVER_SIZE + 20 text_area_height = CARD_HEIGHT - text_y_start - 20 # Información del álbum current_y = text_y_start margin = 15 line_height = 35 # Título del álbum if album_info.album: text = self._wrap_text(draw, album_info.album, self.fonts[\u0026#39;title\u0026#39;], CARD_WIDTH - 2 * margin) for line in text: draw.text((margin, current_y), line, fill=text_primary, font=self.fonts[\u0026#39;title\u0026#39;]) current_y += line_height current_y += 10 # Artista if album_info.artist: text = self._wrap_text(draw, album_info.artist, self.fonts[\u0026#39;artist\u0026#39;], CARD_WIDTH - 2 * margin) for line in text: draw.text((margin, current_y), line, fill=text_secondary, font=self.fonts[\u0026#39;artist\u0026#39;]) current_y += line_height - 5 current_y += 15 # Géneros if album_info.genres: genres_text = \u0026#34; • \u0026#34;.join(album_info.genres[:3]) # Máximo 3 géneros text = self._wrap_text(draw, f\u0026#34;Géneros: {genres_text}\u0026#34;, self.fonts[\u0026#39;info\u0026#39;], CARD_WIDTH - 2 * margin) for line in text: draw.text((margin, current_y), line, fill=text_secondary, font=self.fonts[\u0026#39;info\u0026#39;]) current_y += 25 # Sello if album_info.label: text = self._wrap_text(draw, f\u0026#34;Sello: {album_info.label}\u0026#34;, self.fonts[\u0026#39;info\u0026#39;], CARD_WIDTH - 2 * margin) for line in text: draw.text((margin, current_y), line, fill=text_secondary, font=self.fonts[\u0026#39;info\u0026#39;]) current_y += 25 # Fecha if album_info.date: draw.text((margin, current_y), f\u0026#34;Fecha: {album_info.date}\u0026#34;, fill=text_secondary, font=self.fonts[\u0026#39;info\u0026#39;]) # Borde sutil de la tarjeta draw.rectangle([0, 0, CARD_WIDTH-1, CARD_HEIGHT-1], outline=border_color, width=2) return image def generate_back_card(self, album_info: AlbumInfo) -\u0026gt; Image.Image: \u0026#34;\u0026#34;\u0026#34;Genera la cara B (tracklist) de la tarjeta con colores dinámicos y códigos QR\u0026#34;\u0026#34;\u0026#34; # Obtener paleta de colores bg_color = album_info.color_palette[\u0026#39;background\u0026#39;] text_primary = album_info.color_palette[\u0026#39;text_primary\u0026#39;] text_secondary = album_info.color_palette[\u0026#39;text_secondary\u0026#39;] border_color = album_info.color_palette[\u0026#39;border\u0026#39;] # Crear imagen base con color de fondo dinámico image = Image.new(\u0026#39;RGB\u0026#39;, (CARD_WIDTH, CARD_HEIGHT), bg_color) draw = ImageDraw.Draw(image) margin = 20 current_y = margin + 10 # Título con información del álbum (en lugar de \u0026#34;TRACKLIST\u0026#34;) album_header = f\u0026#34;{album_info.artist} - {album_info.album}\u0026#34; album_header = self._truncate_text(draw, album_header, self.fonts[\u0026#39;title\u0026#39;], CARD_WIDTH - 2 * margin) draw.text((margin, current_y), album_header, fill=text_primary, font=self.fonts[\u0026#39;title\u0026#39;]) current_y += 50 # Línea separadora separator_color = ColorAnalyzer.get_border_color(bg_color) draw.line([(margin, current_y), (CARD_WIDTH - margin, current_y)], fill=separator_color, width=2) current_y += 20 # Calcular espacio disponible para pistas (más margen para evitar corte de QR codes) qr_section_height = 180 # Aumentado para evitar que se corten los QR codes available_height = CARD_HEIGHT - current_y - qr_section_height - margin # Lista de pistas track_height = 26 max_tracks = max(1, available_height // track_height) tracks_to_show = min(len(album_info.tracks), max_tracks) for i in range(tracks_to_show): track = album_info.tracks[i] # Número de pista track_num = f\u0026#34;{track[\u0026#39;number\u0026#39;]:02d}.\u0026#34; draw.text((margin, current_y), track_num, fill=text_secondary, font=self.fonts[\u0026#39;track\u0026#39;]) # Título de la pista title_x = margin + 40 max_title_width = CARD_WIDTH - title_x - margin title = self._truncate_text(draw, track[\u0026#39;title\u0026#39;], self.fonts[\u0026#39;track\u0026#39;], max_title_width) draw.text((title_x, current_y), title, fill=text_primary, font=self.fonts[\u0026#39;track\u0026#39;]) current_y += track_height # Si hay más pistas, indicar if len(album_info.tracks) \u0026gt; tracks_to_show: remaining = len(album_info.tracks) - tracks_to_show draw.text((margin, current_y), f\u0026#34;... y {remaining} pistas más\u0026#34;, fill=text_secondary, font=self.fonts[\u0026#39;info\u0026#39;]) current_y += 25 # Sección de códigos QR qr_y_start = CARD_HEIGHT - qr_section_height + 25 # Más margen superior para mejor posicionamiento # Línea separadora antes de los QR codes draw.line([(margin, qr_y_start - 15), (CARD_WIDTH - margin, qr_y_start - 15)], fill=separator_color, width=1) # Generar y colocar códigos QR qr_size = 120 # Duplicado de 60 a 120 qr_spacing = 20 label_height = 30 qr_codes = [] qr_labels = [] # QR Wikipedia del artista if album_info.qr_links.get(\u0026#39;wikipedia_artist\u0026#39;): qr_wiki = QRCodeGenerator.create_qr_code( album_info.qr_links[\u0026#39;wikipedia_artist\u0026#39;], size=qr_size, bg_color=bg_color, # Usar color de fondo de la tarjeta fg_color=text_primary # Usar color de texto primario para contraste ) if qr_wiki: qr_codes.append(qr_wiki) qr_labels.append(\u0026#34;Wikipedia\u0026#34;) # QR Genius del álbum if album_info.qr_links.get(\u0026#39;genius_album\u0026#39;): qr_genius = QRCodeGenerator.create_qr_code( album_info.qr_links[\u0026#39;genius_album\u0026#39;], size=qr_size, bg_color=bg_color, # Usar color de fondo de la tarjeta fg_color=text_primary # Usar color de texto primario para contraste ) if qr_genius: qr_codes.append(qr_genius) qr_labels.append(\u0026#34;Letras\u0026#34;) # Colocar los QR codes horizontalmente con nuevo orden if qr_codes: total_qr_width = len(qr_codes) * qr_size + (len(qr_codes) - 1) * qr_spacing qr_start_x = (CARD_WIDTH - total_qr_width) // 2 # Primero dibujar las etiquetas ARRIBA de los QR codes label_y = qr_y_start + 5 # Etiquetas en la parte superior qr_y = label_y + 25 # QR codes debajo de las etiquetas for i, (qr_code, label) in enumerate(zip(qr_codes, qr_labels)): qr_x = qr_start_x + i * (qr_size + qr_spacing) # Etiqueta ARRIBA del QR bbox = draw.textbbox((0, 0), label, font=self.fonts[\u0026#39;info\u0026#39;]) text_width = bbox[2] - bbox[0] label_x = qr_x + (qr_size - text_width) // 2 draw.text((label_x, label_y), label, fill=text_secondary, font=self.fonts[\u0026#39;info\u0026#39;]) # QR code DEBAJO de la etiqueta image.paste(qr_code, (qr_x, qr_y)) # Borde sutil de la tarjeta draw.rectangle([0, 0, CARD_WIDTH-1, CARD_HEIGHT-1], outline=border_color, width=2) return image def _wrap_text(self, draw, text: str, font, max_width: int) -\u0026gt; List[str]: \u0026#34;\u0026#34;\u0026#34;Divide el texto en líneas que caben en el ancho máximo\u0026#34;\u0026#34;\u0026#34; words = text.split() lines = [] current_line = \u0026#34;\u0026#34; for word in words: test_line = current_line + \u0026#34; \u0026#34; + word if current_line else word bbox = draw.textbbox((0, 0), test_line, font=font) text_width = bbox[2] - bbox[0] if text_width \u0026lt;= max_width: current_line = test_line else: if current_line: lines.append(current_line) current_line = word if current_line: lines.append(current_line) return lines def _truncate_text(self, draw, text: str, font, max_width: int) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Trunca el texto para que quepa en el ancho máximo\u0026#34;\u0026#34;\u0026#34; bbox = draw.textbbox((0, 0), text, font=font) text_width = bbox[2] - bbox[0] if text_width \u0026lt;= max_width: return text # Truncar con \u0026#34;...\u0026#34; ellipsis = \u0026#34;...\u0026#34; max_chars = len(text) while max_chars \u0026gt; 0: truncated = text[:max_chars] + ellipsis bbox = draw.textbbox((0, 0), truncated, font=font) text_width = bbox[2] - bbox[0] if text_width \u0026lt;= max_width: return truncated max_chars -= 1 return ellipsis def main(): \u0026#34;\u0026#34;\u0026#34;Función principal\u0026#34;\u0026#34;\u0026#34; parser = argparse.ArgumentParser(description=\u0026#34;Generador de Tarjetas de Álbumes\u0026#34;) parser.add_argument(\u0026#34;folder\u0026#34;, help=\u0026#34;Carpeta que contiene los archivos del álbum\u0026#34;) parser.add_argument(\u0026#34;-o\u0026#34;, \u0026#34;--output\u0026#34;, help=\u0026#34;Carpeta de salida (por defecto: carpeta del álbum)\u0026#34;) parser.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;Modo verboso\u0026#34;) args = parser.parse_args() if args.verbose: logging.getLogger().setLevel(logging.DEBUG) folder_path = Path(args.folder) if not folder_path.exists(): logger.error(f\u0026#34;La carpeta {folder_path} no existe\u0026#34;) sys.exit(1) output_path = Path(args.output) if args.output else folder_path output_path.mkdir(parents=True, exist_ok=True) try: # Procesar archivos de música logger.info(\u0026#34;Procesando archivos de música...\u0026#34;) processor = MusicFileProcessor(folder_path) audio_files = processor.get_audio_files() if not audio_files: logger.error(\u0026#34;No se encontraron archivos de audio en la carpeta\u0026#34;) sys.exit(1) logger.info(f\u0026#34;Encontrados {len(audio_files)} archivos de audio\u0026#34;) # Extraer información del álbum album_info = processor.extract_album_info(audio_files) logger.info(f\u0026#34;Álbum: {album_info.artist} - {album_info.album}\u0026#34;) # Enriquecer con MusicBrainz logger.info(\u0026#34;Buscando información en MusicBrainz...\u0026#34;) enricher = MusicBrainzEnricher() album_info = enricher.enrich_album_info(album_info) # Descargar portada logger.info(\u0026#34;Descargando portada...\u0026#34;) downloader = CoverArtDownloader() album_info.cover_image = downloader.download_cover(album_info) # Generar tarjetas logger.info(\u0026#34;Generando tarjetas...\u0026#34;) generator = CardGenerator() front_card = generator.generate_front_card(album_info) back_card = generator.generate_back_card(album_info) # Guardar imágenes album_name = album_info.album or \u0026#34;album\u0026#34; album_name = \u0026#34;\u0026#34;.join(c for c in album_name if c.isalnum() or c in (\u0026#39; \u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;)).rstrip() front_path = output_path / f\u0026#34;{album_name}_cara_A.png\u0026#34; back_path = output_path / f\u0026#34;{album_name}_cara_B.png\u0026#34; front_card.save(front_path, dpi=(DPI, DPI)) back_card.save(back_path, dpi=(DPI, DPI)) logger.info(f\u0026#34;Tarjetas guardadas:\u0026#34;) logger.info(f\u0026#34; Cara A: {front_path}\u0026#34;) logger.info(f\u0026#34; Cara B: {back_path}\u0026#34;) # Guardar información del álbum como JSON info_path = output_path / f\u0026#34;{album_name}_info.json\u0026#34; album_data = { \u0026#34;artist\u0026#34;: album_info.artist, \u0026#34;album\u0026#34;: album_info.album, \u0026#34;date\u0026#34;: album_info.date, \u0026#34;label\u0026#34;: album_info.label, \u0026#34;genres\u0026#34;: album_info.genres, \u0026#34;mbid\u0026#34;: album_info.mbid, \u0026#34;tracks\u0026#34;: [{\u0026#34;number\u0026#34;: t[\u0026#34;number\u0026#34;], \u0026#34;title\u0026#34;: t[\u0026#34;title\u0026#34;]} for t in album_info.tracks] } with open(info_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: json.dump(album_data, f, indent=2, ensure_ascii=False) logger.info(f\u0026#34;Información guardada en: {info_path}\u0026#34;) except Exception as e: logger.error(f\u0026#34;Error: {e}\u0026#34;) if args.verbose: import traceback traceback.print_exc() sys.exit(1) if __name__ == \u0026#34;__main__\u0026#34;: main() ","date":"2025-12-18T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/nfc-card-player/","title":"Nfc Card Player"},{"content":"Instala atuin con 1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -LsSf https://setup.atuin.sh | sh Inicialo con tu shell bash:\n1 echo \u0026#39;eval \u0026#34;$(atuin init bash)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc zsh:\n1 echo \u0026#39;eval \u0026#34;$(atuin init zsh)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc fish:\n1 atuin init fish | source nushell:\n1 2 3 4 5 mkdir ~/.local/share/atuin/ atuin init nu | save ~/.local/share/atuin/init.nu # Añade esto a config.nu source ~/.local/share/atuin/init.nu Carga tu historial anterior atuin import auto Importará el shell actual. También se puede especificar que shell importar:\n1 2 atuin import bash atuin import zsh # etc Sincronización Añade esto a ~/.config/atuin/config.toml\n1 sync_address = \u0026#34;http://192.168.1.133:8778\u0026#34; ","date":"2025-12-17T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/atuin.-historial-de-comandos-con-superpoderes/","title":"Atuin. Historial De Comandos Con Superpoderes"},{"content":"Primero edita las opciones de sudo con sudo visudo y añade la línea:\n1 Defaults insults ","date":"2025-12-16T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/se-insultado-al-fallar-contrase%C3%B1a-de-sudo/","title":"Se Insultado Al Fallar Contraseña De Sudo"},{"content":"Edit la configuración de pacman\n1 % vim /etc/pacman.conf Elimina el comentario de la sección [multilib]\n1 2 #[multilib] #Include = /etc/pacman.d/mirrorlist Quedando asi\n1 2 [multilib] Include = /etc/pacman.d/mirrorlist Guarda el archivo y actualiza\n1 % pacman -Syyu Ya puedes instalar Steam:\n1 % pacman -S steam ","date":"2025-11-16T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/instalar-steam-en-archlinux/","title":"Instalar Steam En Archlinux"},{"content":"Añade este script como un alias para poder enviar notificaciones a Telegram cuando finalicen commandos de larga duración\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/bin/bash # Configuración de Telegram BOT_TOKEN=\u0026#34;tu_token_de_bot\u0026#34; CHAT_ID=\u0026#34;tu_chat_id\u0026#34; # Función para enviar mensajes a Telegram send_telegram_message() { MESSAGE=\u0026#34;$1\u0026#34; curl -s -X POST \u0026#34;https://api.telegram.org/bot$BOT_TOKEN/sendMessage\u0026#34; \\ -d chat_id=\u0026#34;$CHAT_ID\u0026#34; \\ -d text=\u0026#34;$MESSAGE\u0026#34; \\ -d parse_mode=\u0026#34;HTML\u0026#34; # Verificar si se proporcionó un mensaje if [ -z \u0026#34;$1\u0026#34; ]; then echo \u0026#34;Uso: $0 \\\u0026#34;Mensaje a enviar\\\u0026#34;\u0026#34; exit 1 fi # Enviar el mensaje send_telegram_message \u0026#34;$1\u0026#34; ","date":"2025-11-12T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/notificaciones-en-telegram/","title":"Notificaciones En Telegram"},{"content":"Tiddlywiki es una aplicación genial para guardar notas en un solo archivo html. Gracias a su api puedes añadir notas usando este commando curl\n1 2 3 4 5 6 curl -X PUT -i \u0026#39;http://192.168.0.12:8080/recipes/default/tiddlers/NewTiddlerTitle\u0026#39; --data \u0026#39;{ \u0026#34;tags\u0026#34;: \u0026#34;firstTag anotherTag\u0026#34;, \u0026#34;creator\u0026#34;: \u0026#34;gene\u0026#34;, \u0026#34;modifier\u0026#34;: \u0026#34;gene\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;The use of knowledge in society\u0026#34; }\u0026#39; -H \u0026#34;X-Requested-With: TiddlyWiki\u0026#34; ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/agregar-nota-a-tiddlywiki/","title":"Agregar Nota A Tiddlywiki"},{"content":" 1 2 3 4 5 # Muestra archivos modificados en el último día find /ruta/a/tu/directorio -type f -mtime -1 #Esto listará los archivos con detalles como permisos, propietario, tamaño y fecha de modificación. find /ruta/a/tu/directorio -type f -mmin -60 -ls ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/archivos-modificados-recientemente/","title":"Archivos Modificados Recientemente"},{"content":" Origen\nVim script Place the following code in your .vimrc before plug#begin() call, and Vim will automatically install vim-plug and the plugins when you open Vim.\n1 2 3 4 5 6 7 8 9 10 11 12 let data_dir = has(\u0026#39;nvim\u0026#39;) ? stdpath(\u0026#39;data\u0026#39;) . \u0026#39;/site\u0026#39; : \u0026#39;~/.vim\u0026#39; if empty(glob(data_dir . \u0026#39;/autoload/plug.vim\u0026#39;)) silent execute \u0026#39;!curl -fLo \u0026#39;.data_dir.\u0026#39;/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; autocmd VimEnter * PlugInstall --sync | source $MYVIMRC endif \u0026#34; An example of vim-plug section --------------------------------------------- call plug#begin() Plug \u0026#39;junegunn/seoul256.vim\u0026#39; call plug#end() silent! colorscheme seoul256 Lua script equivalent for Neovim 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local data_dir = vim.fn.stdpath(\u0026#39;data\u0026#39;) if vim.fn.empty(vim.fn.glob(data_dir .. \u0026#39;/site/autoload/plug.vim\u0026#39;)) == 1 then vim.cmd(\u0026#39;silent !curl -fLo \u0026#39; .. data_dir .. \u0026#39;/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39;) vim.o.runtimepath = vim.o.runtimepath vim.cmd(\u0026#39;autocmd VimEnter * PlugInstall --sync | source $MYVIMRC\u0026#39;) end -- An example of vim-plug section -------------------------------------------- local vim = vim local Plug = vim.fn[\u0026#39;plug#\u0026#39;] vim.call(\u0026#39;plug#begin\u0026#39;) Plug(\u0026#39;junegunn/seoul256.vim\u0026#39;) vim.call(\u0026#39;plug#end\u0026#39;) vim.cmd(\u0026#39;silent! colorscheme seoul256\u0026#39;) ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/automatic-installation-vim-plug/","title":"Automatic Installation Vim Plug"},{"content":"","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/change-lxc-container-root-password/","title":"Change LXC Container Root Password"},{"content":"Convierte el ratón en un selector de colores de tu pantalla\n1 xcolor ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/conseguir-color-de-una-imagen/","title":"Conseguir Color De Una Imagen"},{"content":" 1 magick input.svg -background none -flatten output.png ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/convierte-svg-a-png-con-fondo-transparente/","title":"Convierte Svg A Png Con Fondo Transparente"},{"content":"Tldr link archivos 1 2 ln -s archivo_original link # soft link ln archivo_original link ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-links-de-archivos/","title":"Crear Links De Archivos"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 touch roles/system/tasks/{essential,main,user,ssh}.yml tree roles roles └── system └── tasks ├── essential.yml ├── main.yml ├── ssh.yml └── user.yml 3 directories, 4 files ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-multiples-archivos/","title":"Crear Multiples Archivos"},{"content":"","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-multiples-archivos-oneline/","title":"Crear Multiples Archivos Oneline"},{"content":" stackexchange\nSuelo conectarme a una red con muchas impresoras. Cuando se detectan impresoras, aparecen muchos mensajes molestos en GNOME. Uso la impresora rara vez, así que preferiría mantener CUPS desactivado la mayor parte del tiempo. Detener CUPS funciona y elimina las notificaciones molestas:\n1 systemctl stop cups Me gustaría desactivarlo al arrancar. Sorprendentemente, después de desactivarlo,\n1 systemctl disabled cups CUPS sigue ejecutándose después de reiniciar. El commando de estado\n1 systemctl status cups ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/desactivar-servicio-de-impresi%C3%B3n/","title":"Desactivar Servicio De Impresión"},{"content":" Origen\n1 glxinfo | grep -E -i \u0026#39;device|memory\u0026#39; Ea, a merendar.\n","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/detecta-la-ram-de-tu-gpu/","title":"Detecta La RAM De Tu GPU"},{"content":"Origen\nEl kernel de Linux registrará todos los dispositivos conectados a él durante el inicio y puede encontrarlos con el siguiente commando.\n1 dmesg | grep -i blue Puedes usar bluetoothctl para arrancar la app y luego usar:\n1 2 3 4 5 power on agent on scan on connect MAC_ADDRESS trust MAC_ADDRESS ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/detectar-dispositivos-bluetooth/","title":"Detectar Dispositivos Bluetooth"},{"content":"El PASSWORD_HASH lo puedes generar con:\n1 2 import hashlib print(hashlib.md5(\u0026#34;TU_CONTRASEÑA\u0026#34;.encode()).hexdigest()) O pasándole un argumento\n1 2 3 import hashlib import sys print(hashlib.md5(sys.argv[0].encode()).hexdigest()) ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/hash-una-contrase%C3%B1a/","title":"Hash Una Contraseña"},{"content":" Origen\nUsa esta linea cambiando \u0026lt;img_in\u0026gt; por la imagen a convertir.\n1 magick \u0026lt;img_in\u0026gt; -colorspace Gray \u0026lt;img_out\u0026gt; ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/imagemagick-convertir-imagen-a-tono-de-grises/","title":"Imagemagick Convertir Imagen A Tono De Grises"},{"content":"Usa este snippet para poder insertar enlaces en foros\n1 [url=https://www.bbcode.org/]This is bbcode.org![/url] ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/insertar-url-en-foro/","title":"Insertar Url En Foro"},{"content":"Clona el repositorio\n1 2 git clone https://github.com/iv-org/invidious.git cd invidious Para obtener po_token y visitor_data ejecuta:\n1 docker run quay.io/invidious/youtube-trusted-session-generator Para obtener el hmac:\n1 openssl rand -base64 21 Necesitas editar el docker-compose.yml para añadir estos tres tokens\nTambien puedes correr estos commandos y cargar las variables desde un .env:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash # Ejecutar el contenedor y capturar la salida OUTPUT=$(docker run quay.io/invidious/youtube-trusted-session-generator) # Extraer los valores usando grep y sed o awk VISITOR_DATA=$(echo \u0026#34;$OUTPUT\u0026#34; | grep \u0026#39;visitor_data:\u0026#39; | sed \u0026#39;s/.*visitor_data: *//\u0026#39;) PO_TOKEN=$(echo \u0026#34;$OUTPUT\u0026#34; | grep \u0026#39;po_token:\u0026#39; | sed \u0026#39;s/.*po_token: *//\u0026#39;) # Verifica que se hayan extraído correctamente if [[ -z \u0026#34;$VISITOR_DATA\u0026#34; || -z \u0026#34;$PO_TOKEN\u0026#34; ]]; then echo \u0026#34;Error: No se pudieron extraer los datos correctamente.\u0026#34; exit 1 fi # hmac hmac=\u0026#34;$(openssl rand -base64 21)\u0026#34; # Guardarlos en un archivo .env cat \u0026lt;\u0026lt;EOF \u0026gt; .env VISITOR_DATA=$VISITOR_DATA PO_TOKEN=$PO_TOKEN HMAC=$hmac EOF echo \u0026#34;.env generado correctamente:\u0026#34; cat .env ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/instalar-invidious/","title":"Instalar Invidious"},{"content":" stackoverflow\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #!/bin/bash # Crear alias para goto y usarlo si DEBUG=TRUE shopt -s expand_aliases if [ -n \u0026#34;$DEBUG\u0026#34; ] ; then alias goto=\u0026#34;cat \u0026gt;/dev/null \u0026lt;\u0026lt;\u0026#34; else alias goto=\u0026#34;:\u0026#34; fi # Ir a tag #GOTO_1 goto \u0026#39;#GOTO_1\u0026#39; echo \u0026#34;Don\u0026#39;t run this\u0026#34; #GOTO1 echo \u0026#34;Run this\u0026#34; # Ir a tag #GOTO_2 goto \u0026#39;#GOTO_2\u0026#39; echo \u0026#34;Don\u0026#39;t run this either\u0026#34; #GOTO_2 echo \u0026#34;All done\u0026#34; ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/ir-a-una-l%C3%ADnea-espec%C3%ADfica-del-script/","title":"Ir A Una Línea Específica Del Script"},{"content":"Usa khal para agregar una entrada en el calendario.\nReemplaza las variables del siguiente commando por tus datos.\n1 2 3 khal new -a discos \u0026#34;${fecha}\u0026#34;:::\u0026#34;${title}\u0026#34; zenity –info –text=\u0026#39;creado nuevo evento\u0026#39; ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/khal.-crear-nueva-entrada-en-calendario/","title":"Khal. Crear Nueva Entrada En Calendario"},{"content":"Añade un nuevo usuario así desde el servidor, reemplazando el texto entre llaves:\n1 docker exec {kopia_container_name} kopia server user add {user}@{hostname} ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/kopia-server-add-user/","title":"Kopia Server Add User"},{"content":" Origen\n1 journalctl -f -u mystuff.service -f, --follow Mostrar solo las entradas de diario más recientes e imprimir continuamente las nuevas entradas a medida que se añaden al diario.\n-u, --unit=UNIT|PATTERN\n","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/leer-log-de-un-servicio/","title":"Leer Log De Un Servicio"},{"content":"LUKS Origen\nListar particiones encriptadas 1 2 3 4 5 6 7 8 9 10 11 lsblk -p NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT /dev/sda 8:0 0 931,5G 0 disk ├─/dev/sda1 8:1 0 512M 0 part /boot/efi ├─/dev/sda2 8:2 0 732M 0 part /boot └─/dev/sda3 8:3 0 930,3G 0 part └─/dev/mapper/sda3_crypt 253:0 0 930,3G 0 crypt ├─/dev/mapper/mint--vg-root 253:1 0 929,3G 0 lvm / └─/dev/mapper/mint--vg-swap_1 253:2 0 976M 0 lvm [SWAP] /dev/sr0 Añadir nuevas contraseñas sudo cryptsetup luksAddKey /dev/sda3\nBackups 1 2 3 4 sudo timeshift --create sudo timeshift --list sudo timeshift --restore --snapshot \u0026#34;2020-02-19_18-32-36\u0026#34; sudo timeshift --delete --snapshot \u0026#39;2014-10-12_16-29-08\u0026#39; ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/luks/","title":"Luks"},{"content":"Instalación sudo apt install rcm\nInstalar configuraciones rcup -d /path\nCrear configuraciones mkrc file\n","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/manejo-de-dotfiles-con-rcm/","title":"Manejo De Dotfiles Con RCM"},{"content":"1. Editar regla: sudo nano /etc/udev/rules.d/99-usb-mount.rules\nACTION==\u0026quot;add\u0026quot;, SUBSYSTEM==\u0026quot;block\u0026quot;, ENV{DEVTYPE}==\u0026quot;partition\u0026quot;, ENV{ID_BUS}==\u0026quot;usb\u0026quot;, TAG+=\u0026quot;systemd\u0026quot;, ENV{SYSTEMD_WANTS}=\u0026quot;usb-mount@%k.service\u0026quot;\n2. Crear Servicio sudo nano /etc/systemd/system/usb-mount@.service\n1 2 3 4 5 6 7 8 9 10 11 12 [Unit] Description=Mount USB device %I After=dev-%i.device BindsTo=dev-%i.device [Service] Type=oneshot ExecStart=/usr/local/bin/mount-usb.sh /dev/%I RemainAfterExit=yes [Install] WantedBy=multi-user.target 3. Creamos Script sudo nano /usr/local/bin/mount-usb.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #!/usr/bin/env python3 import os import sys import subprocess import time import logging from datetime import datetime # Configurar logging log_file = \u0026#34;/var/log/usb-mount.log\u0026#34; logging.basicConfig( filename=log_file, level=logging.DEBUG, format=\u0026#39;%(asctime)s - %(levelname)s - %(message)s\u0026#39; ) def mount_usb_and_restart_container(): logging.info(\u0026#34;Script iniciado\u0026#34;) if len(sys.argv) != 2: logging.error(\u0026#34;Error: Se requiere el nombre del dispositivo como argumento\u0026#34;) sys.exit(1) device = sys.argv[1] mount_point = \u0026#34;/mnt/usb\u0026#34; logging.info(f\u0026#34;Procesando dispositivo: {device}\u0026#34;) # Verificar si el dispositivo ya está en fstab try: with open(\u0026#39;/etc/fstab\u0026#39;, \u0026#39;r\u0026#39;) as f: fstab_content = f.read() if device in fstab_content: logging.info(f\u0026#34;El dispositivo {device} ya está definido en fstab. Ignorando.\u0026#34;) sys.exit(0) except Exception as e: logging.error(f\u0026#34;Error al verificar fstab: {e}\u0026#34;) # Verificar si el dispositivo ya está montado en otro lugar try: result = subprocess.run([\u0026#34;findmnt\u0026#34;, \u0026#34;-S\u0026#34;, device], stdout=subprocess.PIPE, text=True) if result.returncode == 0: logging.info(f\u0026#34;El dispositivo {device} ya está montado en otro lugar. Ignorando.\u0026#34;) sys.exit(0) except Exception as e: logging.error(f\u0026#34;Error al verificar montajes: {e}\u0026#34;) # Esperar un momento para asegurar que el dispositivo esté disponible time.sleep(2) # Crear punto de montaje si no existe os.makedirs(mount_point, exist_ok=True) logging.info(f\u0026#34;Punto de montaje creado/verificado: {mount_point}\u0026#34;) # Verificar si ya hay algo montado en el punto de montaje try: result = subprocess.run([\u0026#34;findmnt\u0026#34;, mount_point], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) if result.returncode == 0: logging.info(f\u0026#34;Ya hay un dispositivo montado en {mount_point}. Desmontando...\u0026#34;) subprocess.run([\u0026#34;umount\u0026#34;, mount_point], check=True) except Exception as e: logging.warning(f\u0026#34;Aviso al verificar punto de montaje: {e}\u0026#34;) # Montar el nuevo dispositivo try: # Mostrar el dispositivo que vamos a montar logging.info(f\u0026#34;Intentando montar: {device} en {mount_point}\u0026#34;) subprocess.run([\u0026#34;ls\u0026#34;, \u0026#34;-la\u0026#34;, device], check=False) # Intentar montar mount_result = subprocess.run( [\u0026#34;mount\u0026#34;, device, mount_point], check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True ) if mount_result.returncode == 0: logging.info(f\u0026#34;Dispositivo {device} montado en {mount_point}\u0026#34;) else: logging.error(f\u0026#34;Error al montar: {mount_result.stderr}\u0026#34;) sys.exit(1) except Exception as e: logging.error(f\u0026#34;Excepción al montar el dispositivo: {e}\u0026#34;) sys.exit(1) # Esperar un momento para asegurar que el montaje se completó time.sleep(2) # Reiniciar el contenedor de filebrowser try: logging.info(\u0026#34;Reiniciando contenedor filebrowser\u0026#34;) result = subprocess.run( [\u0026#34;docker\u0026#34;, \u0026#34;restart\u0026#34;, \u0026#34;filebrowser\u0026#34;], check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True ) if result.returncode == 0: logging.info(\u0026#34;Contenedor filebrowser reiniciado con éxito\u0026#34;) else: logging.error(f\u0026#34;Error al reiniciar el contenedor: {result.stderr}\u0026#34;) except Exception as e: logging.error(f\u0026#34;Excepción al reiniciar el contenedor filebrowser: {e}\u0026#34;) sys.exit(1) logging.info(\u0026#34;Script completado correctamente\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: try: mount_usb_and_restart_container() except Exception as e: logging.error(f\u0026#34;Error no controlado: {e}\u0026#34;) 4. Hacer el script ejecutable sudo chmod +x /usr/local/bin/mount-usb.sh\n5. Recargar reglas udev sudo udevadm control --reload-rules\n6. Recargar systemd ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/montar-usb-autom%C3%A1ticamente/","title":"Montar Usb Automáticamente"},{"content":"curl -s \u0026quot;https://decapi.me/youtube/latest_video?user=NPR\n","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/obtener-%C3%BAltimo-video-de-un-canal-de-youtube/","title":"Obtener Último Video De Un Canal De Youtube"},{"content":"How to Reset Your Proxmox LXC Container Root Password Grab the container ID\nFirst you need to grab the container ID, which is the number next to the container name in the Proxmox node. For example, if the container name is “monitor”, the ID will be the number next to it.\nOpen up a shell\nNext, open up a shell (as root) into the container from the Proxmox host. You can do this by running the command “lxc-attach -n [container_id]”, with the appropriate container ID in place of the placeholder.\nFor example, if the container ID is 150, the command would be:\n1 lxc-attach -n 150 Change your password\nFinally, change your password by running the command “passwd”. This will prompt you to enter a new password for your container.\n1 passwd ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/reset-lxc-password/","title":"Reset Lxc Password"},{"content":" superuser\nPrefijo TMUX (p. ej., Ctrl+B) + :kill-session\no\ntmux kill-session (puede ejecutarse desde dentro o desde fuera de una sesión)\nAmbos estilos de invocación pueden usar las siguientes banderas:\n-t target-session destruye la sesión dada -a destruye todas las sesiones excepto la dada o la que está asociada\nEjecutar kill-session desde fuera de TMUX elimina la última sesión a la que estaba asociada. -a invierte la operación.\n","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/tmux-cerrar-resto-de-sesiones/","title":"Tmux Cerrar Resto De Sesiones"},{"content":"Añade esto a tu .zshrc\n1 2 alias -g -- -h=\u0026#39;-h 2\u0026gt;\u0026amp;1 | bat --language=help --style=plain\u0026#39; alias -g -- --help=\u0026#39;--help 2\u0026gt;\u0026amp;1 | bat --language=help --style=plain\u0026#39; ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/usar-bat-para-los-menus-de-ayuda-de-otras-apps/","title":"Usar Bat Para Los Menus De Ayuda De Otras Apps"},{"content":" Origen\nSi quieres forzar el guardado de un archivo con otro nombre en vim puedes usar:\n1 :w !sudo tee /etc/httpd/cyberciti.com.conf ","date":"2025-07-31T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/vim-guardar-archivo-con-nuevo-nombre/","title":"Vim, Guardar Archivo Con Nuevo Nombre"},{"content":"","date":"2025-07-24T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/atuin-historial-del-terminal-con-superpod%C3%A9res/","title":"Atuin   Historial Del Terminal Con Superpodéres"},{"content":"Desactiva Capslock: setxkbmap -option ctrl:nocaps\nPara volver a activarlo:\n","date":"2025-07-24T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/desactivar-may%C3%BAsculas/","title":"Desactivar Mayúsculas"},{"content":"Para eliminar las claves que referencien a dietpi:\n1 ssh-keygen -f \u0026#34;/home/$USER/.ssh/known_hosts\u0026#34; -R \u0026#34;dietpi\u0026#34; ","date":"2025-07-24T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/eliminar-clave-de-known_hosts/","title":"Eliminar Clave De Known_hosts"},{"content":"","date":"2025-07-24T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/fail2ban-how-to-unban-ips-that-are-blocked/","title":"Fail2ban How To Unban Ips That Are Blocked"},{"content":"Configure the host waking up 1 sudo ethtool -s eth0 wol g Access BIOS and enable Wake On Lan.\nHow Do I Send WOL Magic Packets Under Linux? 1 2 3 4 wakeonlan MAC-Address-Here wakeonlan \u0026#34;74:56:3C:5D:E6:1D\u0026#34; # proxmox wakeonlan \u0026#34;30:65:ec:a8:9b:37\u0026#34; # kodi OR\n1 etherwake MAC-Address-Here Crea un servicio para activar wol al inicio 1 2 3 4 5 6 7 8 9 10 11 [Unit] Description=Enable Wake On Lan Requires=network.target After=network.target [Service] Type=oneshot ExecStart = /sbin/ethtool --change enp1s0 wol g [Install] WantedBy=basic.target ","date":"2025-07-23T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/wake-on-lan/","title":"Wake On LAN"},{"content":"Crontab 1 crontab -e \u001b[1;33mImagen no encontrada: /mnt/windows/FTP/wiki/Obsidian/Dibujos/img/Pasted image 20240920220109.png\u001b[0m\nCada 5 minutos 1 */5 * * * * /ruta/a/tu/script.sh ","date":"2025-07-22T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crontab/","title":"Crontab"},{"content":" 1 git restore archivo1 archivo2 Si además de restaurarlos quieres deshacer cualquier cambio que hayas staged con git add, usa:\n1 git restore --staged archivo1 archivo2 git restore archivo1 archivo2 ","date":"2025-07-22T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/git.-retroceder-en-github/","title":"Git. Retroceder En Github"},{"content":" 1 `grep -rHni \u0026#39;cadena_de_texto\u0026#39; .` -r Recursivo. -H mostrar nombre del archivo. -n mostrar línea.\n","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/buscar-cadena-de-texto-en-multiples-archivos/","title":"Buscar Cadena De Texto En Multiples Archivos"},{"content":"Montar 1 sudo mount -t exfat -o uid=1000,gid=1000,umask=022 /source /dest Copiar 1 rsync -avh --info=progress2 --no-perms --no-owner --no-group --ignore-existing --exclude=\u0026#39;temp/*\u0026#39; /mnt/dietpi_userdata/NFS/2TB/moode/ /mnt/500GB/Musica/ ","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/comando-para-copiar-a-exfat/","title":"Comando Para Copiar A Exfat"},{"content":" Origen\nRemove lines from test1 because they are in test2:\n1 grep -vxFf test2 test1 To overwrite test1:\n1 grep -vxFf test2 test1 \u0026gt;test1.tmp \u0026amp;\u0026amp; mv test1.tmp test1 ","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/comparando-dos-archivos-y-removiendo-coincidencias-en-solo-uno/","title":"Comparando Dos Archivos Y Removiendo Coincidencias En Solo Uno"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 sudo netstat -tulnp # requiere instalar net-tools (en debian) sudo ss -tulnp # Puertos especificos: sudo fuser -n tcp \u0026lt;puerto\u0026gt; # se puede cambiar tcp por udp ps -p $(sudo fuser -n tcp 80) # muestra nombre de los PID # Conexiones activas sudo lsof -i -n -P # Usuario concreto lsof -u username # Archivos abiertos por un proceso lsof -p 1234 # Procesos abiertos en un directorio lsof +D /ruta/al/directorio # Actualiza la salida cada 5 segundos lsof -i -n -P -r 5 ","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/comprobar-procesos-conectados-a-internet/","title":"Comprobar Procesos Conectados A Internet"},{"content":" 1 sudo iotop -o ","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/comprobar-que-proceso-usa-el-disco/","title":"Comprobar Que Proceso Usa El Disco"},{"content":"Usar sfdisk para copiar la estructura de particiones Sfdisk es una herramienta de línea de comandos que permite gestionar las particiones de un disco y copiar su tabla de particiones a un archivo. Esta herramienta solo maneja la estructura de particiones, no los datos contenidos en ellas.\nCopiar la estructura de particiones: Exportar la tabla de particiones a un archivo: Usando sfdisk, puedes copiar la tabla de particiones de un dispositivo (por ejemplo, /dev/sda) a un archivo de texto: 1 sudo sfdisk --dump /dev/sda \u0026gt; particiones.txt Esto creará un archivo de texto (particiones.txt) que contiene la estructura de particiones del dispositivo. Este archivo incluye la información sobre los tamaños y las ubicaciones de las particiones, pero no los datos dentro de ellas.\nRestaurar la estructura de particiones en otro dispositivo: Restaurar la tabla de particiones en otro dispositivo: Si quieres crear la misma estructura de particiones en otro dispositivo (por ejemplo, /dev/sdb), puedes usar el archivo exportado para restaurar la tabla de particiones: 1 sudo sfdisk /dev/sdb \u0026lt; particiones.txt ","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/copia-de-particiones-con-dd/","title":"Copia De Particiones Con Dd"},{"content":"Formatear disco 1 2 3 4 5 6 7 8 # Crear nueva tabla de particiones sudo fdisk /dev/sdXY # Orden: g, n, w # Formatear disco mkfs [options] [-t type fs-options] device [size] sudo mkfs -t ext4 /dev/sdb1 # EJEMPLO ","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/formatear-disco/","title":"Formatear Disco"},{"content":" 1 sudo systemctl list-units --type=service ","date":"2025-07-15T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/listar-servicios-systemctl/","title":"Listar Servicios Systemctl"},{"content":"Crea una imagen de una unidad como un disco duro o una tarjeta de memoria.\n1 sudo dd if=/dev/sdX of=name-of-iso.iso status=\u0026#34;progress\u0026#34; ","date":"2025-07-10T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-iso-de-dispositivo/","title":"Crear ISO De Dispositivo"},{"content":"Crea un servidor http en una carpeta para poder descargar archivos rápidamente\n1 python3 -m http.server 8000 --bind 0.0.0.0 --directory /ruta/al/directorio ","date":"2025-07-10T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-servidor-para-compartir-carpeta/","title":"Crear Servidor Para Compartir Carpeta"},{"content":"1.Crear El blog 1 2 3 hugo new site \u0026lt;nombre del sitio\u0026gt; cd \u0026lt;nombre del sitio\u0026gt; git init 3.Elegir Un tema e instalarlo https://themes.gohugo.io/themes/lightbi-hugo/\n1 2 3 4 git submodule add https://github.com/binokochumolvarghese/lightbi-hugo themes/lightbi-hugo echo \u0026#34;theme = \u0026#39;lightbi-hugo\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml hugo server cp -r \u0026#34;themes/lightbi-hugo/example site/*\u0026#34; $web_dir/content/ 4.Comprueba Que funciona localmente 1 hugo serve --bind \u0026#34;0.0.0.0\u0026#34; #--baseURL 192.168.1.14 # ip of server 5.Crea Repositorio en github terminado en .github.io 6.Sube El directorio de la web recien creada 1 2 3 git add . # subira todo el contendio de la carpeta en la que se está git commit -m \u0026#34;comentario\u0026#34; git push 7.Accede A github y ve a Settings \u0026gt; Pages hasta ver esto \u001b[1;33mImagen no encontrada: /mnt/windows/FTP/wiki/Obsidian/Dibujos/img/Pasted image 20240723144203.png\u001b[0m\n8.Cambia source A Github Actions (se guarda solo) \u001b[1;33mImagen no encontrada: /mnt/windows/FTP/wiki/Obsidian/Dibujos/img/Pasted image 20240723144218.png\u001b[0m\n9.Crea Un archivo en .github/workflows/hugo.yaml ¡Importante! Cambiar la versión de hugo a la que esté instalada 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.128.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production TZ: America/Los_Angeles run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 10.Crear Un commit en el repositorio y subirlo 1 2 3 git add . # subira todo el contendio de la carpeta en la que se está git commit -m \u0026#34;comentario\u0026#34; git push 11.En Github, elije Actions \u001b[1;33mImagen no encontrada: /mnt/windows/FTP/wiki/Obsidian/Dibujos/img/Pasted image 20240723144801.png\u001b[0m\nUna vez terminado el push y la creación del sitio debes ver algo así \u001b[1;33mImagen no encontrada: /mnt/windows/FTP/wiki/Obsidian/Dibujos/img/Pasted image 20240723144903.png\u001b[0m\nSe veria asi en el commit\n","date":"2025-07-10T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-web-en-hugo/","title":"Crear Web En Hugo"},{"content":"Devuelve un link corto para compartir facilmente\nDesconozco la duración de dichos enlaces\ncurl https://is.gd/create.php\\?format\\=simple\\\u0026amp;url\\=google.com\n","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/acortar-url/","title":"Acortar Url"},{"content":"Con este comando puedes subir un archivo de texto para compartirlo fácilmente\n1 curl -F file=@starship.toml https://0x0.st ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/compartir-archivo-oneline/","title":"Compartir Archivo Oneline"},{"content":"curl qrenco.de/STRING\necho STRING | curl -F-=\\\u0026lt;- qrenco.de\n","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-c%C3%B3digo-qr-con-texto/","title":"Crear Código Qr Con Texto"},{"content":"Puedes usar estos comandos para añadir aleatoriedad a diferentes programas.\nCommits aleatorios curl -s https://whatthecommit.com/index.txt\nChistes de padres curl https://icanhazdadjoke.com\nPuede usarse por ejemplo en un alias:\n1 2 3 4 5 # Para chezmoi alias chzu=\u0026#39;chezmoi git add . ; chezmoi git -- commit -m \u0026#34;$(curl -s https://whatthecommit.com/index.txt)\u0026#34; ; chezmoi git push\u0026#39; # Para git alias gitodo=\u0026#39;git add . ; git commit -m \u0026#34;$(curl -s https://whatthecommit.com/index.txt)\u0026#34; ; git push\u0026#39; ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/crear-commit-aleatorio/","title":"Crear Commit Aleatorio"},{"content":" Origen\nMuestra los dispositivos conectados a tu LAN en la subnet especificada\n1 sudo nmap -sn 192.168.1.0/24 ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/escanear-red-local/","title":"Escanear red local"},{"content":" Origen\nMacchanger Otro método utilize macchanger (también conocido como GNU MAC Changer). Ofrece diversas funciones, como cambiar la dirección para que coincida con un proveedor específico o aleatorizarla completamente.\nInstala el paquete macchanger.\nLa suplantación se realiza por interfaz. Especifica el nombre de la interfaz de red como interfaz en cada uno de los siguientes commandos.\nLa dirección MAC se puede suplantar con una dirección completamente aleatoria:\n1 macchanger -r interface Para aleatorizar solo los bytes específicos del dispositivo de la dirección MAC actual (es decir, para que, si se verifica la dirección MAC, se registre como del mismo proveedor), ejecuta el commando:\n1 macchanger -e interface Para cambiar la dirección MAC a un valor específico, ejecuta:\n1 macchanger --mac=XX:XX:XX:XX:XX:XX interface Donde XX:XX:XX:XX:XX:XX es la MAC a la que deseas cambiar.\nFinalmente, para restaurar la dirección MAC a su valor de hardware original y permanente:\n1 macchanger -p interface ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/mac-address-spoofing/","title":"Mac Address Spoofing"},{"content":"Para obtener datos sobre la localización de tu servidor usa cualquiera de estos comandos\ncurl ip-api.com curl http://ifconfig.co/json curl ifconfig.es/geo or curl ifconfig.es/json or curl ifconfig.es/country or curl ifconfig.es/code or curl ifconfig.es/city or curl ifconfig.es/latitude or curl ifconfig.es/longitude ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/obtener-geolocalizaci%C3%B3n/","title":"Obtener Geolocalización"},{"content":"Ejecuta cualquiera de estos comandos en un terminal para obtener la ip pública del host.\nIp publica\ncurl ipaddy.net curl eth0.me curl ipaddr.site curl ifconfig.co curl ifconfig.pro curl curlmyip.net curl ipinfo.io/ip curl icanhazip.com curl checkip.amazonaws.com curl ip-api.com/line?fields=query curl ifconfig.io/ip curl -s ip.liquidweb.com curl ifconfig.es curl ipaddress.sh curl 2ip.ru ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/obtener-ip-p%C3%BAblica/","title":"Obtener Ip Pública"},{"content":"Comprueba la velocidad de internet con este script online\n1 curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python - ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/prueba-de-velocidad-de-internet/","title":"Prueba De Velocidad De Internet"},{"content":"Añadir ~/local/bin al path\n1 export PATH=\u0026#34;/home/$USER/.local/bin:$PATH\u0026#34; ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/ruta-al-path/","title":"Ruta Al Path"},{"content":"✅ 1. Configurar el tiempo antes de volver a pedir la contraseña Esto lo controla sudo mediante la opción timestamp_timeout\n🔧 ¿Cómo cambiarlo? Edita o crea un archivo en /etc/sudoers.d/, por ejemplo:\n1 sudo visudo -f /etc/sudoers.d/timeout Y agrega esta línea:\n1 Defaults timestamp_timeout=5 🕐 Esto significa que sudo recordará la contraseña durante 5 minutos. Puedes poner:\n0: pide siempre la contraseña.\n-1: no la vuelve a pedir durante la sesión.\n✅ 2. Hacer que sudo se \u0026ldquo;olvide\u0026rdquo; cuando cerrás SSH Esto se puede hacer de varias formas. La más directa:\n🔧 Método: usar pam_exec para limpiar sudo al cerrar sesión Edita el archivo PAM de tu shell, por ejemplo para bash (esto depende de tu distribución):\n1 sudo nano /etc/pam.d/sshd` Agrega esta línea al final del archivo:\n1 session optional pam_exec.so type=close_session /usr/bin/sudo -K Esto ejecutará sudo -K cuando se cierre una sesión SSH, que borra el timestamp de sudo.\n🧪 Alternativa simple: alias en .bash_logout Si no quieres meterte con pam, puedes hacer algo más simple:\nEn tu Raspberry o servidor remoto, edita:\n1 nano ~/.bash_logout Agregá esta línea:\n1 sudo -K Eso hace que, cuando cierras una sesión interactiva (exit, cerrar shell), se borre el caché de sudo.\n📌 Esto no funciona si usas otro shell que no lee .bash_logout, como zsh. Para zsh, puedes usar ~/.zlogout.\n🧠 Verificación rápida Podés comprobar si el caché está activo con:\n1 sudo -v Y ver si está activo con:\n1 sudo -n true \u0026amp;\u0026amp; echo \u0026#34;Tiene caché sudo\u0026#34; || echo \u0026#34;No tiene caché sudo\u0026#34; ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/sudo-pw-timeout/","title":"Sudo Pw Timeout"},{"content":"Con este linea puedes obtener información sobre el valor de diversas criptomonedas:\n1 curl rate.sx ","date":"2025-07-09T00:00:00Z","permalink":"https://volteret4.github.io/notas/p/valor-criptomonedas-oneline/","title":"Valor Criptomonedas Oneline"}]